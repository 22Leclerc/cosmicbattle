<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>Ambiente C√≥smico ‚Äî Batalha de Her√≥is (Wanda, Fate & Magneto)</title>
<style>
  :root{ --panel-bg:rgba(10,12,20,.62); --panel-brd:rgba(255,255,255,.16); --txt:#e8ecff; }
  html,body{ height:100% }
  body{ margin:0; overflow:hidden; background:radial-gradient(1200px 800px at 50% 50%, #05060b 0%, #02030b 60%, #000 100%); color:var(--txt); font-family:system-ui, Segoe UI, Roboto, Helvetica, Arial; }
  canvas{ display:block; }

  .panel{ position:fixed; top:14px; left:14px; z-index:2; background:var(--panel-bg); border:1px solid var(--panel-brd); backdrop-filter:blur(6px); border-radius:12px; padding:12px 14px; max-width:740px; box-shadow:0 8px 30px rgba(0,0,0,.35); user-select:none; transition:transform .22s ease, opacity .22s ease; }
  .panel h2{ margin:0 0 8px; font-size:14px; letter-spacing:.3px; color:#cfd7ff; display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
  .grid{ display:grid; grid-template-columns:1fr auto; gap:8px; align-items:center; }
  .grid input[type=range]{ width:260px }
  .grid select, .grid input[type=checkbox], .grid input[type=color]{ accent-color:#4f7cff }
  .grid select, .grid input[type=text]{ width:260px; padding:4px 6px; border-radius:8px; border:1px solid var(--panel-brd); background:#0f1733; color:var(--txt) }
  .btns{ display:flex; gap:8px; margin-top:8px; flex-wrap:wrap }
  button{ background:#0f1733; color:#e9efff; border:1px solid var(--panel-brd); padding:6px 10px; border-radius:10px; cursor:pointer; font-size:12px }
  button:hover{ border-color:#2b3d7a }
  .hint{ font-size:11px; opacity:.85; margin-top:6px }
  .badge{ padding:2px 8px; border-radius:999px; font-size:10px; background:#1a2147; border:1px solid var(--panel-brd) }

  .panel.collapsed{ transform:translateX(calc(-100% + 24px)); opacity:.04; pointer-events:none }
  #uiToggle{ position:fixed; top:14px; left:14px; z-index:3; background:var(--panel-bg); border:1px solid var(--panel-brd); border-radius:999px; padding:6px 10px; cursor:pointer; font-size:12px; display:none; color:var(--txt) }

  .scoreboard{ position:fixed; top:14px; right:14px; z-index:2; display:flex; align-items:center; gap:8px; background:var(--panel-bg); border:1px solid var(--panel-brd); backdrop-filter:blur(6px); padding:8px 12px; border-radius:12px; box-shadow:0 8px 30px rgba(0,0,0,.35); font-weight:600 }
  .scoreboard .team{ font-size:12px; opacity:.95; display:flex; align-items:center; gap:6px }
  .scoreboard .dot{ width:10px; height:10px; border-radius:50%; display:inline-block; border:1px solid rgba(255,255,255,.35) }
  .scoreboard .score{ font-size:16px; min-width:22px; text-align:center }
  .scoreboard .sep{ opacity:.6 }

  #iaPanel{ left:auto; right:14px; top:70px; max-width:460px }
  #iaPanel.collapsed{ transform:none; opacity:0; pointer-events:none }
  .sectionTitle{ margin:8px 0 2px; font-size:12px; opacity:.9; border-top:1px dashed var(--panel-brd); padding-top:8px }
</style>
</head>
<body>
<canvas id="cosmos"></canvas>
<button id="uiToggle" title="Mostrar interface (U)">Mostrar UI</button>

<div class="scoreboard" aria-label="Placar">
  <span class="team"><i class="dot" id="dotA" style="background:#ff69b4"></i><span id="nameA">Pink</span></span>
  <span id="scorePink" class="score">0</span>
  <span class="sep">√ó</span>
  <span id="scoreYellow" class="score">0</span>
  <span class="team"><i class="dot" id="dotB" style="background:#ffd400"></i><span id="nameB">Yellow</span></span>
</div>

<!-- Painel principal -->
<div class="panel" id="panel">
  <h2>
    ‚öôÔ∏è Controles C√≥smicos
    <span class="badge" id="fps">60 fps</span>
    <span class="badge" id="starCount">1 estrela</span>
    <span class="badge" id="zoomBadge">100%</span>
    <span class="badge" id="uniBadge">Universo 1√ó</span>
    <span class="badge" id="scoreA">Pink 0</span>
    <span class="badge" id="scoreB">Yellow 0</span>
  </h2>

  <div class="grid">
    <label>Tipo da nova estrela</label>
    <select id="starType">
      <option value="sun">Sequ√™ncia Principal (Sol)</option>
      <option value="white_dwarf">An√£ Branca</option>
      <option value="neutron">Estrela de N√™utrons</option>
      <option value="pulsar">Pulsar</option>
      <option value="magnetar" selected>Magnetar</option>
      <option value="supergiant">Supergigante</option>
      <option value="black_hole">Buraco Negro</option>
    </select>

    <label>Tamanho (nova estrela)</label><input id="starSize" type="range" min="6" max="80" step="1" value="26">
    <label>Velocidade base (her√≥is)</label><input id="speed" type="range" min="0" max="8" step="0.1" value="2.0">
    <label>Gravidade (G global)</label><input id="gravity" type="range" min="0" max="8000" step="10" value="1800">
    <label>Expoente de queda</label><input id="falloff" type="range" min="1.5" max="3.0" step="0.01" value="2.00">
    <label>Raio de influ√™ncia</label><input id="influence" type="range" min="80" max="1600" step="5" value="520">
    <label>Arrasto (drag)</label><input id="drag" type="range" min="0" max="0.2" step="0.002" value="0.02">
    <label>Segundos de rastro</label><input id="trailSecs" type="range" min="0.3" max="10" step="0.1" value="4">
    <label>Largura do rastro</label><input id="trailW" type="range" min="1" max="6" step="0.5" value="2">
    <label>Fade do fundo</label><input id="fade" type="range" min="0.02" max="0.6" step="0.01" value="0.14">
    <label>Estrelas de fundo</label><input id="starfield" type="range" min="0" max="800" step="20" value="360">
    <label>Curvar √≥rbita</label><input id="curve" type="range" min="0" max="1" step="0.01" value="0.15">
    <label>Zoom (rodinha/pin√ßa)</label><input id="zoom" type="range" min="0.3" max="3.0" step="0.01" value="1.00">

    <label>‚öîÔ∏è Batalha autom√°tica</label><input id="battle" type="checkbox" checked>
    <label>Raio de engajamento</label><input id="engage" type="range" min="100" max="700" step="10" value="260">
    <label>Dano global (mult.)</label><input id="dmg" type="range" min="0.5" max="3" step="0.1" value="1.2">
    <label>Supernovas (freq.)</label><input id="supernovaRate" type="range" min="0" max="1" step="0.01" value="0">

    <label>Raios gama (estrelas)</label><input id="mGamma" type="checkbox" checked>
    <label>Freq. raios gama (por estrela/s)</label><input id="gammaRate" type="range" min="0" max="5" step="0.1" value="1.2">
    <label>Velocidade raios gama</label><input id="gammaSpeed" type="range" min="20" max="120" step="2" value="80">
    <label>Espessura m√©dia (px)</label><input id="gammaW" type="range" min="2" max="14" step="0.5" value="6">

    <label>Cooldown do raio (s)</label><input id="boltCd" type="range" min="0.2" max="6" step="0.1" value="2.0">
    <label>Dano do raio (0 = nenhum, 1 = kill)</label><input id="boltDmg" type="range" min="0" max="1" step="0.01" value="1">
    <label>Velocidade do raio (global)</label><input id="boltSpeed" type="range" min="4" max="30" step="0.5" value="12">
    <label>Cooldown dos orbes (s)</label><input id="orbCd" type="range" min="0.2" max="6" step="0.1" value="2.5">
    <label>Vi√©s orbital dos orbes</label><input id="orbSwirl" type="range" min="0" max="1" step="0.01" value="0.85">

    <!-- üîµ Ajustes da ULT do Magneto -->
    <div class="sectionTitle">ULT do Magneto ‚Äì Gravidade nos Alvos</div><div></div>
    <label>G ULT (alvo)</label><input id="magUltG" type="range" min="0" max="12000" step="20" value="5200">
    <label>Raio ULT (alvo)</label><input id="magUltR" type="range" min="120" max="1200" step="5" value="420">

    <label>Som</label><input id="sndOn" type="checkbox" checked>
    <label>Volume</label><input id="sndVol" type="range" min="0" max="1" step="0.01" value="0.35">

    <label>Magias ativas</label>
    <div>
      <label><input id="mBolt" type="checkbox" checked> Raio</label>
      <label style="margin-left:10px"><input id="mOrb" type="checkbox" checked> Orbe</label>
      <label style="margin-left:10px"><input id="mWave" type="checkbox" checked> Pulso</label>
      <label style="margin-left:10px"><input id="mShield" type="checkbox" checked> Escudo</label>
    </div>
  </div>

  <div class="btns">
    <button id="addStar">Adicionar estrela (+)</button>
    <button id="removeStar">Remover √∫ltima</button>
    <button id="clearStars">Limpar estrelas</button>
    <button id="randomize">Dire√ß√µes aleat√≥rias</button>
    <button id="recenter">Recentrar (m√©dia)</button>
    <button id="reset">Reset her√≥is</button>
    <button id="pause">Pausar</button>
    <button id="zeroV">Zerar vel.</button>
    <button id="fullscreen">Tela cheia</button>
    <button id="resetView">Reset vis√£o</button>
    <button id="expandU">Expandir Universo √ó2</button>
    <button id="toggleUI">Ocultar UI (U)</button>
    <button id="resetBattle">Reset batalha</button>
    <button id="toggleIA">Menu IA (I)</button>
    <button id="ultA">ULT Pink (1)</button>
    <button id="ultB">ULT Yellow (2)</button>
    <button id="addHeroA">+ Her√≥i Pink</button>
    <button id="addHeroB">+ Her√≥i Yellow</button>
  </div>
  <div class="hint">
    Dicas: <kbd>Shift</kbd>=warp √ó3 ‚Ä¢ <kbd>Alt</kbd>+arrastar move estrela ‚Ä¢ <kbd>Ctrl</kbd>+clique cria.
    Roda=zoom ‚Ä¢ <kbd>Espa√ßo</kbd>=pan ‚Ä¢ 2√óclique=reset vis√£o ‚Ä¢ Bordas <strong>n√£o</strong> causam dano (apenas ricochete).
  </div>
</div>

<!-- Painel IA (sem Nitro/Atrasos ‚Äî sliders por her√≥i) -->
<div class="panel" id="iaPanel">
  <h2>üß† IA & Presets</h2>
  <div class="grid">
    <!-- PINK -->
    <div class="sectionTitle">Her√≥i Pink</div><div></div>
    <label>Her√≥i</label>
    <select id="hHeroA">
      <option value="wanda" selected>Wanda Maximoff (Escarlate)</option>
      <option value="fate">Doctor Fate (Dourado)</option>
      <option value="magneto">Magneto (Magn√©tico)</option>
      <option value="loki">Loki (Verde)</option>
    </select>
    <label>Nome</label><input id="hNameA" type="text" value="Wanda"/>
    <label>Cor</label><input id="hColorA" type="color" value="#ff1744"/>
    <label>HP M√°x</label><input id="hHpA" type="range" min="60" max="400" step="5" value="120">
    <label>Velocidade</label><input id="hSpeedA" type="range" min="0" max="8" step="0.1" value="2.1">
    <label>Velocidade de Raios</label><input id="hBoltSpeedA" type="range" min="4" max="30" step="0.5" value="12">
    <label>Cooldown da ULT (s)</label><input id="hUltCdA" type="range" min="4" max="60" step="0.5" value="22">
    <label>Precis√£o do raio</label><input id="accBoltA" type="range" min="0" max="1" step="0.01" value="0.75">
    <label>Estilo</label>
    <select id="hStyleA">
      <option value="attack">Ataque</option>
      <option value="balanced" selected>Balanceado</option>
      <option value="defense">Defesa</option>
    </select>
    <label>Auto-ULT</label><input id="autoUltA" type="checkbox" checked>

    <!-- YELLOW -->
    <div class="sectionTitle">Her√≥i Yellow</div><div></div>
    <label>Her√≥i</label>
    <select id="hHeroB">
      <option value="wanda">Wanda Maximoff (Escarlate)</option>
      <option value="fate" selected>Doctor Fate (Dourado)</option>
      <option value="magneto">Magneto (Magn√©tico)</option>
      <option value="loki">Loki (Verde)</option>
    </select>
    <label>Nome</label><input id="hNameB" type="text" value="Fate"/>
    <label>Cor</label><input id="hColorB" type="color" value="#ffd400"/>
    <label>HP M√°x</label><input id="hHpB" type="range" min="60" max="400" step="5" value="110">
    <label>Velocidade</label><input id="hSpeedB" type="range" min="0" max="8" step="0.1" value="2.0">
    <label>Velocidade de Raios</label><input id="hBoltSpeedB" type="range" min="4" max="30" step="0.5" value="12">
    <label>Cooldown da ULT (s)</label><input id="hUltCdB" type="range" min="4" max="60" step="0.5" value="22">
    <label>Precis√£o do raio</label><input id="accBoltB" type="range" min="0" max="1" step="0.01" value="0.75">
    <label>Estilo</label>
    <select id="hStyleB">
      <option value="attack">Ataque</option>
      <option value="balanced" selected>Balanceado</option>
      <option value="defense">Defesa</option>
    </select>
    <label>Auto-ULT</label><input id="autoUltB" type="checkbox" checked>

    <!-- PRESETS -->
    <div class="sectionTitle">Presets</div><div></div>
    <label>Selecionar</label><select id="presetSelect"></select>
    <label>Nome (salvar)</label><input id="presetName" type="text" placeholder="Meu preset"/>
  </div>
  <div class="btns">
    <button id="presetApply">Aplicar</button>
    <button id="presetSave">Salvar preset</button>
    <button id="presetDelete">Excluir preset</button>
    <button id="closeIA">Fechar IA</button>
  </div>
</div>
<script>
/* =========================================================
   COSMOS ‚Äî N√∫cleo de UI e Configs por Her√≥i (Parte 1/4)
   ========================================================= */
(() => {
// ---------- Utils ----------
const ui = id => document.getElementById(id);
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const hexToRgba=(hex,a=1)=>{ if(!hex) return `rgba(255,255,255,${a})`;
  const h=hex.replace('#',''); const b=parseInt(h.length===3?h.split('').map(c=>c+c).join(''):h,16);
  const r=(b>>16)&255,g=(b>>8)&255,bl=b&255; return `rgba(${r},${g},${bl},${a})`;
};

// ---------- Mapa da UI ----------
const U = {
  // Placar
  nameA: ui('nameA'), nameB: ui('nameB'), dotA: ui('dotA'), dotB: ui('dotB'),
  scorePinkEl: ui('scorePink'), scoreYellowEl: ui('scoreYellow'),
  scoreA: ui('scoreA'), scoreB: ui('scoreB'),

  // Globais
  starType: ui('starType'), starSize: ui('starSize'),
  speed: ui('speed'), gravity: ui('gravity'), falloff: ui('falloff'), influence: ui('influence'),
  drag: ui('drag'), trailSecs: ui('trailSecs'), trailW: ui('trailW'), fade: ui('fade'),
  starfield: ui('starfield'), curve: ui('curve'), zoom: ui('zoom'),
  battle: ui('battle'), engage: ui('engage'), dmg: ui('dmg'), supernovaRate: ui('supernovaRate'),
  mGamma: ui('mGamma'), gammaRate: ui('gammaRate'), gammaSpeed: ui('gammaSpeed'), gammaW: ui('gammaW'),
  boltCd: ui('boltCd'), boltDmg: ui('boltDmg'), boltSpeed: ui('boltSpeed'),
  orbCd: ui('orbCd'), orbSwirl: ui('orbSwirl'),

  // üîµ Ajustes ULT Magneto (alvos com gravidade)
  magUltG: ui('magUltG'), magUltR: ui('magUltR'),

  sndOn: ui('sndOn'), sndVol: ui('sndVol'),
  mBolt: ui('mBolt'), mOrb: ui('mOrb'), mWave: ui('mWave'), mShield: ui('mShield'),

  // Bot√µes principais
  addStar: ui('addStar'), removeStar: ui('removeStar'), clearStars: ui('clearStars'),
  randomize: ui('randomize'), recenter: ui('recenter'), reset: ui('reset'), pause: ui('pause'),
  zeroV: ui('zeroV'), fullscreen: ui('fullscreen'), resetView: ui('resetView'),
  expandU: ui('expandU'), resetBattle: ui('resetBattle'), toggleUI: ui('toggleUI'),
  fps: ui('fps'), starCount: ui('starCount'), zoomBadge: ui('zoomBadge'), uniBadge: ui('uniBadge'),
  ultA: ui('ultA'), ultB: ui('ultB'), addHeroA: ui('addHeroA'), addHeroB: ui('addHeroB'),

  // Painel IA por her√≥i
  iaPanel: ui('iaPanel'), toggleIA: ui('toggleIA'), closeIA: ui('closeIA'),
  // A
  hHeroA: ui('hHeroA'), hNameA: ui('hNameA'), hColorA: ui('hColorA'),
  hHpA: ui('hHpA'), hSpeedA: ui('hSpeedA'), hBoltSpeedA: ui('hBoltSpeedA'), hUltCdA: ui('hUltCdA'),
  accBoltA: ui('accBoltA'), hStyleA: ui('hStyleA'), autoUltA: ui('autoUltA'),
  // B
  hHeroB: ui('hHeroB'), hNameB: ui('hNameB'), hColorB: ui('hColorB'),
  hHpB: ui('hHpB'), hSpeedB: ui('hSpeedB'), hBoltSpeedB: ui('hBoltSpeedB'), hUltCdB: ui('hUltCdB'),
  accBoltB: ui('accBoltB'), hStyleB: ui('hStyleB'), autoUltB: ui('autoUltB'),

  // Presets
  presetSelect: ui('presetSelect'), presetName: ui('presetName'),
  presetApply: ui('presetApply'), presetSave: ui('presetSave'), presetDelete: ui('presetDelete')
};

// ---------- Constantes ----------
const NITRO = { force: 3.0, cap: 3.0, recharge: 0.8 };
const THINK = { min: 0.12, max: 0.26 };

// ---------- Kits ----------
const HERO_KITS = {
  wanda:   { key:'wanda',   name:'Wanda',   full:'Wanda Maximoff', label:'Wanda Maximoff (Escarlate)', base:'#ff1744', hp:120, speedMul:1.05, boltMul:1.00, ultCd:22, accBolt:0.75, think:THINK, ultName:'Piscar Escarlate' },
  fate:    { key:'fate',    name:'Fate',    full:'Doctor Fate',    label:'Doctor Fate (Dourado)',      base:'#ffd400', hp:110, speedMul:1.00, boltMul:0.96, ultCd:22, accBolt:0.74, think:THINK, ultName:'Ankh Dourada' },
  magneto: { key:'magneto', name:'Magneto', full:'Magneto',        label:'Magneto (Magn√©tico)',        base:'#7f8cff', hp:135, speedMul:0.98, boltMul:1.08, ultCd:26, accBolt:0.78, think:THINK, ultName:'Colapso Magn√©tico' },
  // üü¢ LOKI ‚Äî novo her√≥i
  loki:    { key:'loki',    name:'Loki',    full:'Loki Laufeyson', label:'Loki (Verde)',                base:'#00c853', hp:105, speedMul:1.08, boltMul:1.02, ultCd:20, accBolt:0.77, think:THINK, ultName:'Espelhos do Trapaceiro' }
};

// ---------- Config atual ----------
const teamCfg = {
  A: { kit:'wanda', name:'Wanda', color:'#ff1744', hp:120, speedMul:1.05, boltMul:1.00, ultCd:22, accBolt:0.75, style:'balanced', autoUlt:true },
  B: { kit:'fate',  name:'Fate',  color:'#ffd400', hp:110, speedMul:1.00, boltMul:0.96, ultCd:22, accBolt:0.74, style:'balanced', autoUlt:true }
};

// ---------- Sincroniza√ß√£o UI <-> Config ----------
function syncScoreboard(){
  U.nameA.textContent = teamCfg.A.name || 'Pink';
  U.nameB.textContent = teamCfg.B.name || 'Yellow';
  U.dotA.style.background = teamCfg.A.color || '#ff69b4';
  U.dotB.style.background = teamCfg.B.color || '#ffd400';
  U.scoreA.textContent = `${teamCfg.A.name} ${U.scorePinkEl.textContent}`;
  U.scoreB.textContent = `${U.scoreYellowEl.textContent} ${teamCfg.B.name}`;
}

function applyKitToUI(team, kitKey){
  const kit = HERO_KITS[kitKey]; if(!kit) return;
  const isA = (team==='A');
  (isA?U.hHeroA:U.hHeroB).value = kitKey;

  if(isA){
    if(!(U.hNameA.value||'').trim()) U.hNameA.value = kit.name;
    U.hColorA.value = kit.base;
    U.hHpA.value = kit.hp;
    U.hSpeedA.value = (kit.speedMul*2).toFixed(2);
    U.hBoltSpeedA.value = (kit.boltMul*12).toFixed(2);
    U.hUltCdA.value = kit.ultCd;
    U.accBoltA.value = kit.accBolt;
  }else{
    if(!(U.hNameB.value||'').trim()) U.hNameB.value = kit.name;
    U.hColorB.value = kit.base;
    U.hHpB.value = kit.hp;
    U.hSpeedB.value = (kit.speedMul*2).toFixed(2);
    U.hBoltSpeedB.value = (kit.boltMul*12).toFixed(2);
    U.hUltCdB.value = kit.ultCd;
    U.accBoltB.value = kit.accBolt;
  }
  syncCfgFromUI(team);
  syncScoreboard();
}

function syncUIFromCfg(team){
  const c = teamCfg[team]; const isA=(team==='A');
  if(isA){
    U.hHeroA.value=c.kit; U.hNameA.value=c.name; U.hColorA.value=c.color;
    U.hHpA.value=c.hp; U.hSpeedA.value=(c.speedMul*2).toFixed(2);
    U.hBoltSpeedA.value=(c.boltMul*12).toFixed(2); U.hUltCdA.value=c.ultCd;
    U.accBoltA.value=c.accBolt; U.hStyleA.value=c.style; U.autoUltA.checked=c.autoUlt;
  }else{
    U.hHeroB.value=c.kit; U.hNameB.value=c.name; U.hColorB.value=c.color;
    U.hHpB.value=c.hp; U.hSpeedB.value=(c.speedMul*2).toFixed(2);
    U.hBoltSpeedB.value=(c.boltMul*12).toFixed(2); U.hUltCdB.value=c.ultCd;
    U.accBoltB.value=c.accBolt; U.hStyleB.value=c.style; U.autoUltB.checked=c.autoUlt;
  }
  syncScoreboard();
}

function syncCfgFromUI(team){
  const isA=(team==='A');
  const read = isA ? {
    kit: U.hHeroA.value, name: U.hNameA.value, color: U.hColorA.value,
    hp: +U.hHpA.value, speedMul: clamp(+U.hSpeedA.value/2, 0, 4),
    boltMul: clamp(+U.hBoltSpeedA.value/12, 0.1, 4), ultCd: +U.hUltCdA.value,
    accBolt: +U.accBoltA.value, style: U.hStyleA.value, autoUlt: !!U.autoUltA.checked
  } : {
    kit: U.hHeroB.value, name: U.hNameB.value, color: U.hColorB.value,
    hp: +U.hHpB.value, speedMul: clamp(+U.hSpeedB.value/2, 0, 4),
    boltMul: clamp(+U.hBoltSpeedB.value/12, 0.1, 4), ultCd: +U.hUltCdB.value,
    accBolt: +U.accBoltB.value, style: U.hStyleB.value, autoUlt: !!U.autoUltB.checked
  };
  teamCfg[team] = { ...teamCfg[team], ...read };
  syncScoreboard();
}

// ---------- Preenche selects com TODOS os her√≥is (inclui Loki) ----------
function populateHeroSelects(){
  const order = ['wanda','fate','magneto','loki'];
  const fill = (sel, current) => {
    const keep = current || sel.value;
    sel.innerHTML = '';
    for(const k of order){
      const kit = HERO_KITS[k]; if(!kit) continue;
      const o = document.createElement('option');
      o.value = k; o.textContent = kit.label || kit.full || kit.name || k;
      sel.appendChild(o);
    }
    sel.value = (keep && HERO_KITS[keep]) ? keep : (order[0] || '');
  };
  fill(U.hHeroA, teamCfg.A.kit);
  fill(U.hHeroB, teamCfg.B.kit);
}

// ---------- Bindings IA ----------
function bindIA(){
  U.hHeroA.addEventListener('input', ()=>applyKitToUI('A', U.hHeroA.value));
  U.hHeroB.addEventListener('input', ()=>applyKitToUI('B', U.hHeroB.value));

  ['hNameA','hColorA','hHpA','hSpeedA','hBoltSpeedA','hUltCdA','accBoltA','hStyleA','autoUltA']
    .forEach(id=>U[id].addEventListener('input', ()=>syncCfgFromUI('A')));
  ['hNameB','hColorB','hHpB','hSpeedB','hBoltSpeedB','hUltCdB','accBoltB','hStyleB','autoUltB']
    .forEach(id=>U[id].addEventListener('input', ()=>syncCfgFromUI('B')));

  const toggleIA = ()=> U.iaPanel.classList.toggle('collapsed');
  U.toggleIA.addEventListener('click', toggleIA);
  U.closeIA.addEventListener('click', toggleIA);
  addEventListener('keydown', e=>{
    const k=(e.key||'').toLowerCase(); if(k==='i' && !e.ctrlKey && !e.metaKey){
      const t=(document.activeElement&&document.activeElement.tagName)||'';
      if(!['INPUT','SELECT','TEXTAREA'].includes(t)) toggleIA();
    }
  });
}

// ---------- Presets ----------
const BUILTINS = {
  'Padr√£o':{ },
  'Duelos longos':{ dmg:0.8, engage:300, speed:1.5, gravity:1400, drag:0.03, gammaRate:0.6 },
  'Caos gravitacional':{ gravity:3600, falloff:1.7, influence:800, drag:0.01, starfield:600, gammaRate:1.8, gammaSpeed:96 },
  'Supernovas altas':{ supernovaRate:0.8, gravity:1200, speed:2.2, gammaRate:1.2 },
  'Defensivo':{ engage:280, gammaRate:0.9 }
};

function loadCustomPresets(){ try{ return JSON.parse(localStorage.getItem('cosmo-presets-v2')||'{}'); }catch{ return {}; } }
function saveCustomPresets(db){ localStorage.setItem('cosmo-presets-v2', JSON.stringify(db)); }
function refreshPresetSelect(){
  const custom = loadCustomPresets();
  U.presetSelect.innerHTML='';
  const add = (k,grp)=>{ const o=document.createElement('option'); o.value=`${grp}:${k}`; o.textContent=(grp==='B'?'(pr√©) ':'')+k; U.presetSelect.appendChild(o); };
  Object.keys(BUILTINS).forEach(k=>add(k,'B'));
  Object.keys(custom).forEach(k=>add(k,'C'));
}
function serializeSettings(){
  return {
    // globais
    speed:+U.speed.value, gravity:+U.gravity.value, falloff:+U.falloff.value, influence:+U.influence.value, drag:+U.drag.value,
    trailSecs:+U.trailSecs.value, trailW:+U.trailW.value, fade:+U.fade.value, starfield:+U.starfield.value, curve:+U.curve.value,
    battle:!!U.battle.checked, engage:+U.engage.value, dmg:+U.dmg.value, supernovaRate:+U.supernovaRate.value,
    mGamma:!!U.mGamma.checked, gammaRate:+U.gammaRate.value, gammaSpeed:+U.gammaSpeed.value, gammaW:+U.gammaW.value,
    boltCd:+U.boltCd.value, boltDmg:+U.boltDmg.value, boltSpeed:+U.boltSpeed.value, orbCd:+U.orbCd.value, orbSwirl:+U.orbSwirl.value,

    // üîµ ULT Magneto (alvos)
    magUltG:+U.magUltG.value, magUltR:+U.magUltR.value,

    sndOn:!!U.sndOn.checked, sndVol:+U.sndVol.value, mBolt:!!U.mBolt.checked, mOrb:!!U.mOrb.checked, mWave:!!U.mWave.checked, mShield:!!U.mShield.checked,
    // por-her√≥i
    A:{...teamCfg.A}, B:{...teamCfg.B}
  };
}
function applySettings(obj){
  const set=(el,v)=>{ if(el==null||v===undefined) return; if(el.type==='checkbox') el.checked=!!v; else el.value=v; };
  ['speed','gravity','falloff','influence','drag','trailSecs','trailW','fade','starfield','curve',
   'engage','dmg','supernovaRate','gammaRate','gammaSpeed','gammaW','boltCd','boltDmg','boltSpeed','orbCd','orbSwirl',
   'magUltG','magUltR','sndVol']
   .forEach(k=> set(U[k], obj[k]));
  ['battle','mGamma','mBolt','mOrb','mWave','mShield','sndOn'].forEach(k=> set(U[k], obj[k]));
  if(obj.A){ teamCfg.A = {...teamCfg.A, ...obj.A}; syncUIFromCfg('A'); }
  if(obj.B){ teamCfg.B = {...teamCfg.B, ...obj.B}; syncUIFromCfg('B'); }
  refreshPresetSelect();
}
U.presetApply.addEventListener('click', ()=>{
  const v=U.presetSelect.value||''; const [grp,name]=v.split(':'); const custom=loadCustomPresets();
  const src = grp==='C' ? custom[name] : BUILTINS[name]; if(src) applySettings(src);
});
U.presetSave.addEventListener('click', ()=>{
  const name=(U.presetName.value||'Preset').trim(); if(!name) return;
  const custom=loadCustomPresets(); custom[name]=serializeSettings(); saveCustomPresets(custom); refreshPresetSelect(); U.presetName.value='';
});
U.presetDelete.addEventListener('click', ()=>{
  const v=U.presetSelect.value||''; const [grp,name]=v.split(':'); if(grp!=='C') return;
  const custom=loadCustomPresets(); delete custom[name]; saveCustomPresets(custom); refreshPresetSelect();
});

// ---------- Exporta para o motor (Parte 2) ----------
window.__COSMO_CFG__ = {
  U, HERO_KITS, teamCfg, NITRO, THINK,
  hexToRgba, clamp,
  applyKitToUI, syncUIFromCfg, syncCfgFromUI, syncScoreboard,
  refreshPresetSelect
};

// Inicializa√ß√£o
populateHeroSelects();
bindIA();
applyKitToUI('A', teamCfg.A.kit);
applyKitToUI('B', teamCfg.B.kit);
refreshPresetSelect();

})(); // fim Parte 1/4
</script>
<script>
/* =========================================================
   COSMOS ‚Äî Motor de jogo (Parte 2/4)
   ========================================================= */
(() => {
  const {
    U, HERO_KITS, teamCfg, NITRO, THINK,
    hexToRgba, clamp, applyKitToUI, syncUIFromCfg, syncCfgFromUI, syncScoreboard, refreshPresetSelect
  } = window.__COSMO_CFG__;

  // Canvas & c√¢mera
  const canvas = document.getElementById('cosmos');
  const ctx     = canvas.getContext('2d');

  let DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  let CW=0, CH=0;

  function resize(){
    CW = innerWidth; CH = innerHeight;
    canvas.style.width = CW+'px'; canvas.style.height = CH+'px';
    canvas.width  = Math.floor(CW*DPR);
    canvas.height = Math.floor(CH*DPR);
  }
  resize();
  addEventListener('resize', ()=>{ DPR=Math.max(1,Math.min(2,devicePixelRatio||1)); resize(); makeStarfield(+U.starfield.value); });

  const camera = { x:0, y:0, scale:1, min:0.3, max:3 };
  let worldScaleFactor = 1, WW=CW*1.0, WH=CH*1.0;

  function centerCamera(){ camera.x=WW/2; camera.y=WH/2; }
  function screenToWorld(sx,sy){ const wx=(sx-CW/2)/camera.scale+camera.x; const wy=(sy-CH/2)/camera.scale+camera.y; return {x:wx,y:wy}; }
  function setZoomAt(target,sx,sy){
    const pre=screenToWorld(sx,sy);
    camera.scale = clamp(target,camera.min,camera.max);
    const post=screenToWorld(sx,sy);
    camera.x += pre.x-post.x; camera.y += pre.y-post.y;
    U.zoom.value = camera.scale.toFixed(2); updateBadges();
  }
  function zoomBy(f,sx,sy){ setZoomAt(camera.scale*f,sx,sy); }
  function updateBadges(){
    U.zoomBadge.textContent = Math.round(camera.scale*100)+'%';
    U.uniBadge.textContent  = `Universo ${worldScaleFactor}\u00D7`;
  }
  function withCamera(fn){ ctx.save(); ctx.translate(CW/2,CH/2); ctx.scale(camera.scale,camera.scale); ctx.translate(-camera.x,-camera.y); fn(); ctx.restore(); }
  function fillCircle(x,y,r,rgba){ ctx.beginPath(); ctx.arc(x,y,Math.max(0,r+0.01),0,Math.PI*2-1e-4); ctx.fillStyle=rgba; ctx.fill(); }
  function strokeHalo(x,y,r,w,rgba){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2-1e-4); ctx.lineWidth=w; ctx.strokeStyle=rgba; ctx.stroke(); }
  const len2=(x,y)=>Math.hypot(x,y);
  const unit=a=>({x:Math.cos(a),y:Math.sin(a)});
  const randAngle = ()=> Math.random()*Math.PI*2;

  // Pan/zoom
  let panning=false, movingStar=false, panStart={sx:0,sy:0,cx:0,cy:0};
  const keys={shift:false, space:false};
  addEventListener('keydown',e=>{
    const k=(e.key||'').toLowerCase();
    if(k==='shift') keys.shift=true;
    if(k===' ') keys.space=true;
    if(k==='1') dispatchEvent(new CustomEvent('cosmo:ultA'));
    if(k==='2') dispatchEvent(new CustomEvent('cosmo:ultB'));
  });
  addEventListener('keyup',e=>{
    const k=(e.key||'').toLowerCase();
    if(k==='shift') keys.shift=false;
    if(k===' ') keys.space=false;
  });

  canvas.addEventListener('contextmenu',e=>e.preventDefault());
  canvas.addEventListener('pointerdown',e=>{
    const sx=e.clientX, sy=e.clientY;
    const {x,y} = screenToWorld(sx,sy);
    if(e.ctrlKey){ addStar(x,y); return; }
    if(e.altKey){ movingStar=true; moveNearestStarTo(x,y); return; }
    if(e.button===1||e.button===2||keys.space){ panning=true; panStart={sx,sy,cx:camera.x,cy:camera.y}; canvas.setPointerCapture && canvas.setPointerCapture(e.pointerId); return; }
  });
  canvas.addEventListener('pointermove',e=>{
    const sx=e.clientX, sy=e.clientY;
    const {x,y} = screenToWorld(sx,sy);
    if(movingStar) moveNearestStarTo(x,y);
    if(panning){ const dx=(sx-panStart.sx)/camera.scale, dy=(sy-panStart.sy)/camera.scale; camera.x=panStart.cx-dx; camera.y=panStart.cy-dy; }
  });
  addEventListener('pointerup',e=>{ movingStar=false; if(panning){ panning=false; canvas.releasePointerCapture && canvas.releasePointerCapture(e.pointerId); }});
  canvas.addEventListener('wheel',e=>{ e.preventDefault(); const f=Math.pow(1.1,-e.deltaY/100); zoomBy(f,e.clientX,e.clientY); },{passive:false});
  canvas.addEventListener('dblclick',()=>{ camera.scale=1; centerCamera(); U.zoom.value=camera.scale; updateBadges(); });

  // Universo
  const STAR_TYPES={
    sun:{massScale:1,color:'#fff4b2',halo:'rgba(255,231,147,1)',spinSpeed:0.005},
    white_dwarf:{massScale:3,color:'#e8f3ff',halo:'rgba(207,230,255,1)',spinSpeed:0.008},
    neutron:{massScale:6,color:'#a8d8ff',halo:'rgba(126,194,255,1)',spinSpeed:0.05},
    pulsar:{massScale:8,color:'#c3e6ff',halo:'rgba(157,211,255,1)',spinSpeed:0.12},
    magnetar:{massScale:10,color:'#b9fff4',halo:'rgba(116,255,233,1)',spinSpeed:0.06},
    supergiant:{massScale:12,color:'#ffd1a3',halo:'rgba(255,178,122,1)',spinSpeed:0.004},
    black_hole:{massScale:20,color:'#000000',halo:'rgba(154,169,255,1)',spinSpeed:0.01}
  };
  const stars=[];

  function addStar(x,y,type=U.starType.value,r=+U.starSize.value){
    const st=STAR_TYPES[type]||STAR_TYPES.sun;
    stars.push({x,y,r,type,massScale:st.massScale,spin:0,spinSpeed:st.spinSpeed,gammaT:0,gammaPol:false});
    updateStarCount();
  }
  function removeStar(){ stars.pop(); updateStarCount(); }
  function clearStars(){ stars.length=0; updateStarCount(); }
  function updateStarCount(){ U.starCount.textContent=`${stars.length} ${stars.length===1?'estrela':'estrelas'}`; }
  function moveNearestStarTo(x,y){
    if(!stars.length) return;
    let best=0,bd=Infinity; for(let i=0;i<stars.length;i++){ const s=stars[i]; const d=(s.x-x)**2+(s.y-y)**2; if(d<bd){ bd=d; best=i; } }
    stars[best].x=x; stars[best].y=y;
  }

  // Starfield
  let bgStars=[];
  function makeStarfield(val){
    const baseN=Math.floor(val);
    const areaFactor=Math.max(1,Math.round((WW*WH)/(CW*CH)));
    const N=Math.min(20000,baseN*areaFactor);
    bgStars=Array.from({length:N},()=>({x:Math.random()*WW,y:Math.random()*WH,s:Math.random()*1.5+0.2,a:Math.random()*0.8+0.2}));
  }

  // ‚ö†Ô∏è TINT REMOVIDO ‚Äî mantido apenas stub para compatibilidade
  function activateTint(){ /* no-op */ }

  function drawBackground(){
    ctx.fillStyle=`rgba(0,0,0,${+U.fade.value})`;
    ctx.setTransform(DPR,0,0,DPR,0,0);
    ctx.fillRect(0,0,CW,CH);
    // (sem overlay de tint)
  }

  function drawStarfield(){
    const vw=CW/camera.scale, vh=CH/camera.scale;
    const x0=camera.x-vw/2-10, x1=camera.x+vw/2+10;
    const y0=camera.y-vh/2-10, y1=camera.y+vh/2+10;
    withCamera(()=>{ 
      for(const s of bgStars){
        if(s.x<x0||s.x>x1||s.y<y0||s.y>y1) continue; 
        ctx.globalAlpha=s.a; ctx.fillStyle='#fff'; ctx.fillRect(s.x,s.y,s.s,s.s); 
      } 
      ctx.globalAlpha=1; 
    });
  }

  function drawBeamsLocal(star,r){
    const type=star.type; const beamsN=(type==='pulsar')?2:4; const baseAlpha=(type==='magnetar')?0.22:0.35;
    for(let i=0;i<beamsN;i++){
      const ang=star.spin+(i*(Math.PI*2/beamsN)); const len=r*5,w=r*0.45;
      ctx.save(); ctx.translate(star.x,star.y); ctx.rotate(ang);
      const grad=ctx.createLinearGradient(0,0,len,0);
      const c1=(type==='magnetar')?'rgba(180,255,240,0)':'rgba(255,255,255,0)';
      const c2=(type==='magnetar')?'rgba(180,255,240,1)':'rgba(220,240,255,1)';
      grad.addColorStop(0.0,c1); grad.addColorStop(0.2,`rgba(255,255,255,${baseAlpha})`); grad.addColorStop(1.0,c2);
      ctx.fillStyle=grad; ctx.beginPath(); ctx.moveTo(0,-w/2); ctx.lineTo(len,-w/2); ctx.lineTo(len,w/2); ctx.lineTo(0,w/2); ctx.closePath(); ctx.fill(); ctx.restore();
    }
    if(type==='magnetar'){ const puls=1+Math.sin(star.spin*2)*0.08; strokeHalo(star.x,star.y,r*1.8*puls,1.5,'rgba(116,255,233,0.5)'); }
  }
  function drawAccretionDiskLocal(s,r){
    const R1=r*1.2,R2=r*3.5; ctx.save(); ctx.translate(s.x,s.y); ctx.rotate(s.spin*0.7);
    const grad=ctx.createRadialGradient(0,0,R1,0,0,R2);
    grad.addColorStop(0,'rgba(255,240,200,0.15)'); grad.addColorStop(0.5,'rgba(220,200,255,0.25)'); grad.addColorStop(1,'rgba(120,140,255,0.0)');
    ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(0,0,R2,0,Math.PI*2-1e-4); ctx.arc(0,0,R1,0,Math.PI*2-1e-4,true); ctx.fill(); ctx.restore();
  }
  function drawStar(s){
    const st=STAR_TYPES[s.type], r=s.r;
    withCamera(()=>{
      const grd=ctx.createRadialGradient(s.x,s.y,0,s.x,s.y,r*4);
      grd.addColorStop(0,st.halo.replace('1)','0.9)')); grd.addColorStop(0.3,st.halo.replace('1)','0.45)')); grd.addColorStop(1,'rgba(0,0,0,0)');
      ctx.fillStyle=grd; ctx.beginPath(); ctx.arc(s.x,s.y,r*4,0,Math.PI*2-1e-4); ctx.fill();
      s.spin+=st.spinSpeed;
      if(s.type==='pulsar'||s.type==='neutron'||s.type==='magnetar') drawBeamsLocal(s,r);
      if(s.type==='black_hole'){ drawAccretionDiskLocal(s,r); fillCircle(s.x,s.y,r*0.9,'#000'); }
      else { ctx.shadowBlur=60; ctx.shadowColor=st.color; fillCircle(s.x,s.y,r,st.color); ctx.shadowBlur=0; }
    });
  }

  // Sons
  const SND = (function(){
    const C = window.AudioContext || window.webkitAudioContext;
    var a, master, enabled = true;
    try {
      if(!C) throw 0;
      a = new C();
      master = a.createGain();
      master.gain.value = .35;
      master.connect(a.destination);
    } catch (e) {
      return {
        boom: function(){}, hit: function(){}, zap: function(){}, orb: function(){},
        wave: function(){}, shield: function(){}, supernova: function(){}, gamma: function(){},
        setEnabled: function(){}, setVol: function(){}, unlock: function(){}
      };
    }

    function unlock(){ if(a.state==='suspended') a.resume(); }
    function setEnabled(v){ enabled = !!v; }
    function setVol(v){ master.gain.value = Math.max(0, Math.min(1, +v||0)); }
    function tone(opts){
      opts = opts || {};
      var freq=opts.freq||440, dur=opts.dur||.12, type=opts.type||'sine', vol=opts.vol||.4;
      var attack=opts.attack||.005, release=opts.release||.08, glideTo=opts.glideTo||null;
      if(!enabled) return;
      var now=a.currentTime, osc=a.createOscillator(), g=a.createGain();
      osc.type=type; osc.frequency.setValueAtTime(freq, now);
      if(glideTo){ osc.frequency.exponentialRampToValueAtTime(Math.max(30,glideTo), now+dur); }
      g.gain.setValueAtTime(.0001, now);
      g.gain.linearRampToValueAtTime(vol, now+attack);
      g.gain.exponentialRampToValueAtTime(.0001, now+Math.max(attack, dur-release));
      osc.connect(g); g.connect(master); osc.start(now); osc.stop(now+dur+.02);
    }
    function noise(opts){
      opts = opts || {};
      var dur=opts.dur||.35, vol=opts.vol||.4;
      if(!enabled) return;
      var len=Math.floor(a.sampleRate*dur), buf=a.createBuffer(1,len,a.sampleRate), data=buf.getChannelData(0);
      for(var i=0;i<len;i++) data[i]=Math.random()*2-1;
      var src=a.createBufferSource(); src.buffer=buf; var g=a.createGain(); g.gain.value=vol; src.connect(g); g.connect(master);
      var now=a.currentTime; g.gain.setValueAtTime(vol,now); g.gain.exponentialRampToValueAtTime(.0001,now+dur); src.start(now); src.stop(now+dur+.05);
    }
    var boom=function(){ noise({dur:.5,vol:.35}); tone({freq:90,dur:.45,type:'sine',vol:.22,glideTo:60}); };
    var hit =function(){ tone({freq:340,dur:.08,type:'square',vol:.18,glideTo:220}); };
    var zap =function(){ tone({freq:1200,dur:.18,type:'sawtooth',vol:.15,glideTo:500}); };
    var orb =function(){ tone({freq:600,dur:.06,type:'triangle',vol:.12}); };
    var wave=function(){ tone({freq:180,dur:.22,type:'sine',vol:.18}); };
    var shield=function(){ tone({freq:520,dur:.30,type:'triangle',vol:.14}); };
    var supernova=function(){ boom(); setTimeout(boom,120); };
    var gamma=function(){ tone({freq:2100,dur:.06,type:'sawtooth',vol:.18}); };

    U.sndOn && U.sndOn.addEventListener('input',function(){ setEnabled(U.sndOn.checked); });
    U.sndVol && U.sndVol.addEventListener('input',function(){ setVol(+U.sndVol.value); });
    addEventListener('pointerdown',unlock,{once:true}); addEventListener('keydown',unlock,{once:true});
    setVol(+U.sndVol?.value||0.35);

    return { boom:boom, hit:hit, zap:zap, orb:orb, wave:wave, shield:shield, supernova:supernova, gamma:gamma,
             setEnabled:setEnabled, setVol:setVol, unlock:unlock };
  })();

  // UI
  const panelEl=document.getElementById('panel');
  const uiToggleBtn=document.getElementById('uiToggle');
  let uiCollapsed=false;
  function setUICollapsed(b){ uiCollapsed=b; panelEl.classList.toggle('collapsed',b); uiToggleBtn.style.display=b?'inline-block':'none'; }
  U.toggleUI.onclick=()=>setUICollapsed(!uiCollapsed);
  uiToggleBtn.onclick=()=>setUICollapsed(false);
  addEventListener('keydown',e=>{
    const k=(e.key||'').toLowerCase();
    if((k==='u'||k==='h')&&!e.ctrlKey&&!e.metaKey){
      const t=(document.activeElement&&document.activeElement.tagName)||'';
      if(['INPUT','SELECT','TEXTAREA'].includes(t)) return; setUICollapsed(!uiCollapsed);
    }
  });

  // Bot√µes universo
  U.addStar.onclick = ()=> addStar(camera.x+(Math.random()-.5)*CW, camera.y+(Math.random()-.5)*CH);
  U.removeStar.onclick = removeStar;
  U.clearStars.onclick = clearStars;
  U.recenter.onclick=()=>{ if(stars.length===0) return; const cx=stars.reduce((a,s)=>a+s.x,0)/stars.length; const cy=stars.reduce((a,s)=>a+s.y,0)/stars.length; const dx=WW/2-cx,dy=WH/2-cy; for(const s of stars){ s.x+=dx; s.y+=dy; } };
  U.fullscreen.onclick=()=>{ if(!document.fullscreenElement){ (document.documentElement.requestFullscreen||document.body.requestFullscreen).call(document.documentElement||document.body); } else { document.exitFullscreen&&document.exitFullscreen(); } };
  U.resetView.onclick=()=>{ camera.scale=1; centerCamera(); U.zoom.value=camera.scale; updateBadges(); };
  U.expandU.onclick=()=>{ worldScaleFactor*=2; const cx=camera.x,cy=camera.y; const oldWW=WW,oldWH=WH; WW=CW*worldScaleFactor; WH=CH*worldScaleFactor; camera.x=cx+(WW-oldWW)/2; camera.y=cy+(WH-oldWH)/2; makeStarfield(+U.starfield.value); updateBadges(); };
  U.zoom.addEventListener('input',()=>setZoomAt(+U.zoom.value,CW/2,CH/2));

  // ULT buttons -> eventos
  U.ultA.onclick=()=>dispatchEvent(new CustomEvent('cosmo:ultA'));
  U.ultB.onclick=()=>dispatchEvent(new CustomEvent('cosmo:ultB'));

  // Inicializa√ß√£o de estrelas
  function initWorld(){
    WW=CW*worldScaleFactor; WH=CH*worldScaleFactor;
    clearStars();
    const defs = [
      {type:'magnetar',     r:42},
      {type:'neutron',      r:26},
      {type:'pulsar',       r:34},
      {type:'white_dwarf',  r:20},
      {type:'supergiant',   r:48},
      {type:'sun',          r:30}
    ];
    const margin = Math.min(WW,WH)*0.15;
    for(const d of defs){
      let x = margin + Math.random()*(WW-2*margin);
      let y = margin + Math.random()*(WH-2*margin);
      addStar(x,y,d.type,d.r);
    }
    centerCamera(); makeStarfield(+U.starfield.value); updateBadges(); syncScoreboard();
  }
  initWorld();

  // Exposi√ß√£o para Parte 3/4 e 4/4
  window.__COSMO_CORE__ = {
    canvas, ctx, DPR:()=>DPR, CW:()=>CW, CH:()=>CH, camera,
    withCamera, fillCircle, strokeHalo, unit, len2, randAngle,

    stars, STAR_TYPES, addStar, removeStar, clearStars, makeStarfield, drawStar, drawStarfield, drawBackground,

    SND, activateTint,  // <- stub (no-op)

    WW: () => WW,
    WH: () => WH,

    updateBadges
  };

})(); // fim Parte 2/4
</script>
<script>
/* =========================================================
   COSMOS ‚Äî Her√≥is, Combate, IA e Loop (Parte 3/4)
   Altera√ß√µes:
   ‚Ä¢ Wanda: ULT d√° escudo invulner√°vel vermelho (wInvul) ‚Äî n√£o usa Ankh.
   ‚Ä¢ Wanda Passiva: Bolt Duplo a cada 10s (dois tiros paralelos).
   ‚Ä¢ Doctor Fate: 10% CDR por stack (m√°x. 50%), ULT dura 5s.
   ========================================================= */
(() => {
  const {
    U, HERO_KITS, teamCfg, NITRO, THINK,
    hexToRgba, clamp
  } = window.__COSMO_CFG__;

  const CORE = window.__COSMO_CORE__;
  if (!CORE) { console.error('[Parte 3/4] __COSMO_CORE__ ausente.'); return; }

  const {
    canvas, ctx, DPR, CW, CH, camera,
    withCamera, fillCircle, strokeHalo, unit, len2, randAngle,
    stars, STAR_TYPES, addStar, removeStar, clearStars, makeStarfield, drawStar, drawStarfield, drawBackground,
    SND, WW:WW_get, WH:WH_get, updateBadges
  } = CORE;

  // Estado
  const projectiles = [];
  const bolts       = [];
  const waves       = [];
  const effects     = [];
  const gBeams      = [];

  // ------------------ ULT VISUAL/ALVOS MAGNETO ------------------
  const magUlts = []; // { caster, t0, until }
  function addMagnetoField(caster, ms){
    const now = performance.now();
    magUlts.push({ caster, t0: now, until: now + (ms||1100) });
  }
  function purgeMagUlts(now){ for(let i=magUlts.length-1;i>=0;i--) if(now>=magUlts[i].until) magUlts.splice(i,1); }
  function isMagUlting(h){ const now=performance.now(); for(const m of magUlts){ if(m.caster===h && now<m.until) return true; } return false; }
  function removeMagnetoFieldsOf(hero){ for(let i=magUlts.length-1;i>=0;i--) if(magUlts[i].caster===hero) magUlts.splice(i,1); }

  // ------------------ LOKI: ILUS√ïES/CLONES ------------------
  const illusions = []; // { caster, id, x,y, r, hex, color, accBolt, boltMul, cd:{bolt}, until, orbitR, orbitA }
  function spawnLokiClones(caster, secs=3.0){
    const now = performance.now();
    const green = '#00c853';
    const base = {
      caster,
      id: caster.id,
      r: caster.r,
      accBolt: caster.accBolt*0.98,
      boltMul: caster.boltMul*1.00,
      cd: { bolt: Math.random()*0.2 }
    };
    const R = 26;
    for(let i=0;i<2;i++){
      illusions.push({
        ...base,
        x: caster.x, y: caster.y,
        hex: green, color: hexToRgba(green, 0.90),
        until: now + secs*1000,
        orbitR: R,
        orbitA: i===0 ? 0 : Math.PI
      });
    }
  }
  function cancelIllusionsOf(hero, fx=true){
    for(let i=illusions.length-1;i>=0;i--){
      if(illusions[i].caster===hero){
        if(fx) effects.push({type:'hit',x:illusions[i].x,y:illusions[i].y,t:0,dur:0.35,color:hexToRgba(illusions[i].hex,0.95)});
        illusions.splice(i,1);
      }
    }
  }
  function updateIllusions(dt){
    const now=performance.now();
    for(let i=illusions.length-1;i>=0;i--){
      const il = illusions[i];
      const host = il.caster;
      if(now>=il.until || !host || !host.alive){
        effects.push({type:'hit',x:il.x,y:il.y,t:0,dur:0.35,color:hexToRgba(il.hex,0.95)});
        illusions.splice(i,1);
        continue;
      }
      il.orbitA += dt*3.2;
      il.x = host.x + Math.cos(il.orbitA)*il.orbitR;
      il.y = host.y + Math.sin(il.orbitA)*il.orbitR;

      il.cd.bolt = Math.max(0, il.cd.bolt - dt);
      const foe = nearestEnemyOf(host);
      if(foe && il.cd.bolt<=0){
        castBoltTravel(il, foe);
        il.cd.bolt = Math.max(0.2, (+U.boltCd.value||2.0)*0.55);
      }
    }
  }
  function drawIllusions(){
    withCamera(()=>{
      for(const il of illusions){
        ctx.beginPath(); ctx.arc(il.x, il.y, il.r, 0, Math.PI*2-1e-4);
        ctx.fillStyle = il.color; ctx.shadowBlur=18; ctx.shadowColor=il.color; ctx.globalAlpha=0.85;
        ctx.fill(); ctx.shadowBlur=0; ctx.globalAlpha=1;
        const a = 0.35 + 0.25*Math.sin(performance.now()/160 + il.orbitA);
        strokeHalo(il.x, il.y, il.r+10, 1.8, hexToRgba(il.hex, a));
      }
    });
  }

  const scores = { A:0, B:0 };
  function updateScores(){
    U.scorePinkEl.textContent = scores.A;
    U.scoreYellowEl.textContent = scores.B;
    U.scoreA.textContent = `${teamCfg.A.name} ${scores.A}`;
    U.scoreB.textContent = `${scores.B} ${teamCfg.B.name}`;
  }

  // Vida / spawn
  const SPAWN_GRACE = 1.5;
  const SAFE_BORDER = 64;
  const SAFE_FROM_STAR = 140;

  function spawnExplosion(x,y,color=null){ effects.push({type:'boom',x,y,t:0,dur:0.6,color}); SND.boom(); }
  function spawnHit(x,y,color){ effects.push({type:'hit',x,y,t:0,dur:0.25,color}); SND.hit(); }

  // ‚ö†Ô∏è Invulnerabilidade/barreiras: inclui wInvul (Wanda Ult Shield)
  function isInvulnerable(h){ return (h.grace>0) || (h.ankh>0) || (h.wInvul>0); }
  function barrierActive(h){ return (h.ankh>0) || (h.shield>0) || (h.wInvul>0); }
  function barrierRadius(h){
    if(h.wInvul>0) return h.r + 22; // escudo vermelho da Wanda
    if(h.ankh>0)   return h.r + 22; // ankh dourada (Fate)
    if(h.shield>0) return h.r + 10; // escudo normal
    return h.r + 6;
  }

  function findSafeSpawn(){
    const WW = WW_get(), WH = WH_get();
    for(let tries=0; tries<50; tries++){
      const x = SAFE_BORDER + Math.random()*(WW - SAFE_BORDER*2);
      const y = SAFE_BORDER + Math.random()*(WH - SAFE_BORDER*2);
      let ok = true;
      for(const s of stars){ const d=Math.hypot(x-s.x,y-s.y); if(d < (s.r + SAFE_FROM_STAR)) { ok=false; break; } }
      if(ok) return {x,y};
    }
    return {x:WW*0.5, y:WH*0.5};
  }

  // --- Util de steering (homing) ---
  function steerTowards(obj, tx, ty, blend){
    const dx=tx-obj.x, dy=ty-obj.y;
    const d=Math.max(1, Math.hypot(dx,dy));
    const sp=Math.hypot(obj.vx||0,obj.vy||0) || 1;
    const tvx=dx/d*sp, tvy=dy/d*sp;
    obj.vx=(obj.vx||0)*(1-blend)+tvx*blend;
    obj.vy=(obj.vy||0)*(1-blend)+tvy*blend;
  }

  // --- Fate Stacks (c√°lculo & CDR = 10%/stack, m√°x. 50%) ---
  function fateStacksFor(h){
    if(h.kit!=='fate') return 0;
    const infl=+U.influence.value||0;
    if(infl<=0) return 0;
    let n=0;
    for(const s of stars){
      const d=Math.hypot(h.x-s.x,h.y-s.y);
      if(d<=infl){ n++; if(n>=5) break; }
    }
    return Math.min(5,n);
  }
  function fateCDMul(h){
    if(h.kit!=='fate') return 1;
    const per = 0.10;                 // 10% por stack
    const stacks = fateStacksFor(h);  // 0..5
    const red = Math.min(0.50, stacks * per);
    return Math.max(0.2, 1 - red);
  }

  function makeHero(team){
    const cfg = teamCfg[team], kit=HERO_KITS[cfg.kit];
    const spot = findSafeSpawn();
    const h = {
      id:team, kit:cfg.kit, label:cfg.name,
      x:spot.x, y:spot.y, vx:0, vy:0, r:5.5,
      hex:cfg.color, color:hexToRgba(cfg.color,0.95),
      trail:[],
      maxHp:cfg.hp, hp:cfg.hp,
      shield:0, ankh:0, wInvul:0,               // ‚Üê Wanda Ult Shield (vermelho)
      cd:{bolt:0,orb:0,wave:0,shield:0},
      ultCD:0, ultMax:cfg.ultCd,
      alive:true, respawn:0,
      style:cfg.style, accBolt:cfg.accBolt,
      thinkMin:kit.think.min, thinkMax:kit.think.max,
      speedMul:cfg.speedMul, boltMul:cfg.boltMul,
      nitro:{charge:NITRO.cap, cap:NITRO.cap},
      grace:SPAWN_GRACE,

      // tempor√°rios e passivas
      hasteUntil: 0,
      _lokiBlinkNext: 0,
      magnetoRoamUntil: 0,
      // Wanda passiva (bolt duplo)
      wandaDoubleT: (cfg.kit==='wanda'? 10.0 : 0.0)
    };
    return h;
  }

  const heroes = [ makeHero('A'), makeHero('B') ];
  function heroesOf(team){ return heroes.filter(h=>h.id===team); }
  function enemiesOf(team){ return heroes.filter(h=>h.id!==team); }
  function nearestEnemyOf(hero){
    let best=null,bd=Infinity; for(const foe of enemiesOf(hero.id)){ if(!foe.alive) continue; const d=(foe.x-hero.x)**2+(foe.y-hero.y)**2; if(d<bd){ bd=d; best=foe; } } return best;
  }
  function addHero(team){ const h=makeHero(team); heroes.push(h); seedVelocities(); updateScores(); }

  function seedVelocities(){
    for(const h of heroes){
      const a=randAngle(); const u=unit(a);
      const base=+U.speed.value * h.speedMul;
      h.vx=u.x*base; h.vy=u.y*base;
    }
  }
  seedVelocities();

  // Dano & kill
  function damage(target,amount,knock={x:0,y:0},sourceTeam=null){
    if(!target.alive) return;
    if(isInvulnerable(target)) return;
    if(target.shield>0) return;

    const mult = +U.dmg.value;
    target.hp -= amount * mult;
    target.vx += knock.x; target.vy += knock.y;

    spawnHit(target.x, target.y, target.color);

    // Magneto: ao cair <50% HP => ativa roaming por 5s
    if(target.kit==='magneto' && target.alive){
      const now=performance.now();
      if(target.hp/Math.max(1,target.maxHp) < 0.5 && now >= (target.magnetoRoamUntil||0)){
        target.magnetoRoamUntil = now + 5000;
      }
    }

    if(target.hp<=0){
      kill(target, sourceTeam);
    }
  }

  function kill(h,killerTeam){
    if(!h.alive) return;
    if(isInvulnerable(h)) return;

    // limpar estados
    cancelIllusionsOf(h, true);
    removeMagnetoFieldsOf(h);

    h.alive=false; h.respawn=2.5;
    spawnExplosion(h.x,h.y,h.color);

    if(killerTeam && killerTeam !== h.id){
      scores[killerTeam]++; updateScores();
    }
  }

  function tryRespawn(h){
    if(h.alive) return;
    h.respawn -= dtGlobal;
    if(h.respawn>0) return;

    const fresh = makeHero(h.id);
    Object.assign(h, {
      id:fresh.id, kit:fresh.kit, label:fresh.label,
      x:fresh.x, y:fresh.y, vx:0, vy:0, r:fresh.r, hex:fresh.hex, color:fresh.color,
      trail:[], maxHp:fresh.maxHp, hp:fresh.hp,
      shield:0, ankh:0, wInvul:0,
      cd:{bolt:0,orb:0,wave:0,shield:0},
      ultCD:0, ultMax:fresh.ultMax, alive:true, respawn:0,
      style:fresh.style, accBolt:fresh.accBolt,
      thinkMin:fresh.thinkMin, thinkMax:fresh.thinkMax,
      speedMul:fresh.speedMul, boltMul:fresh.boltMul,
      nitro:{charge:NITRO.cap, cap:NITRO.cap}, grace:SPAWN_GRACE,
      hasteUntil:0, _lokiBlinkNext:0, magnetoRoamUntil:0,
      wandaDoubleT: (fresh.kit==='wanda'? 10.0 : 0.0)
    });
  }

  // Desenho her√≥i + campos/auras
  function drawHero(h){
    if(!h.alive) return;
    const now=performance.now();
    const life=+U.trailSecs.value*1000;
    const pts=h.trail.filter(p=>now-p.t<=life);
    withCamera(()=>{
      if(pts.length>1){
        ctx.beginPath(); ctx.moveTo(pts[0].x,pts[0].y);
        for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x,pts[i].y);
        const grad=ctx.createLinearGradient(pts[0].x,pts[0].y,pts[pts.length-1].x,pts[pts.length-1].y);
        grad.addColorStop(0,h.color.replace(/0\.95\)/,'0.00)'));
        grad.addColorStop(1,h.color);
        ctx.strokeStyle=grad; ctx.lineWidth=+U.trailW.value; ctx.stroke();
      }

      // Corpo
      ctx.beginPath(); ctx.arc(h.x,h.y,h.r,0,Math.PI*2-1e-4);
      ctx.fillStyle=h.color; ctx.shadowBlur=24; ctx.shadowColor=h.color; ctx.fill(); ctx.shadowBlur=0;

      // Barras
      const bw=42,bh=4,px=h.x-bw/2,py=h.y-14;
      ctx.fillStyle='rgba(255,255,255,0.18)'; ctx.fillRect(px,py,bw,bh);
      const frac=Math.max(0,h.hp/h.maxHp); ctx.fillStyle='rgba(120,240,120,0.9)'; ctx.fillRect(px,py,bw*frac,bh);
      const nfrac=Math.max(0,h.nitro.charge/h.nitro.cap); ctx.fillStyle='rgba(120,180,255,0.9)'; ctx.fillRect(px,py+bh+2,bw*nfrac,bh*0.8);

      // Escudos/Invulns
      if(h.shield>0){ strokeHalo(h.x,h.y,h.r+8,2,'rgba(120,200,255,0.95)'); }
      if(h.ankh>0){ const r=h.r+22; const puls=1+Math.sin(now/220)*0.06; strokeHalo(h.x,h.y,r*puls,2.4,'rgba(255,215,0,0.95)'); }
      if(h.wInvul>0){ // Wanda ult shield (vermelho)
        const r=h.r+22; const a=0.35+0.25*Math.sin(now/170);
        strokeHalo(h.x,h.y,r,2.4,hexToRgba('#ff3050',0.95));
        ctx.globalAlpha=0.14+0.10*Math.sin(now/200);
        fillCircle(h.x,h.y,r*0.92,hexToRgba('#ff3050',0.35));
        ctx.globalAlpha=1;
      }
      if(h.grace>0){ const r2=h.r+14; const a=0.35+0.25*Math.sin(now/160); strokeHalo(h.x,h.y,r2,1.8,`rgba(200,255,200,${a.toFixed(3)})`); }

      // Campo de for√ßa do Magneto durante ULT
      if(h.kit==='magneto' && isMagUlting(h)){
        const r1 = 70*(1+0.06*Math.sin(now/130));
        const r2 = 70*1.25*(1+0.05*Math.cos(now/180));
        const col = hexToRgba(h.hex,0.65);
        strokeHalo(h.x,h.y,r1,2.2,col);
        ctx.globalAlpha=0.30;
        fillCircle(h.x,h.y,r1*0.92,hexToRgba(h.hex,0.10));
        ctx.globalAlpha=1;
        ctx.save();
        ctx.translate(h.x,h.y);
        ctx.rotate(now/600);
        ctx.strokeStyle=hexToRgba(h.hex,0.85);
        ctx.lineWidth=2;
        for(let i=0;i<3;i++){
          const a0=i*(Math.PI*2/3)+(now%1200)/1200*2*Math.PI*0.7;
          ctx.beginPath();
          ctx.arc(0,0,r2,a0,a0+Math.PI/3);
          ctx.stroke();
        }
        ctx.restore();
      }

      // Aura do Magneto quando <50% HP / roaming
      if(h.kit==='magneto' && (now < (h.magnetoRoamUntil||0) || h.hp/h.maxHp<0.5)){
        const rA = h.r + 20 + 6*Math.sin(now/140);
        strokeHalo(h.x,h.y,rA,2,hexToRgba('#9aa3ff',0.9));
        ctx.globalAlpha=0.18;
        fillCircle(h.x,h.y,rA*0.9,hexToRgba('#9aa3ff',0.25));
        ctx.globalAlpha=1;
      }

      // Doctor Fate ‚Äî runas/stacks
      if(h.kit==='fate'){
        const stacks = fateStacksFor(h);
        const R = 16;
        for(let i=0;i<stacks;i++){
          const ang = now/420 + i*(Math.PI*2/Math.max(1,stacks));
          const rx = h.x + Math.cos(ang)*R;
          const ry = h.y + Math.sin(ang)*R;
          ctx.save();
          ctx.translate(rx,ry);
          ctx.rotate(Math.PI/4 + ang*0.6);
          ctx.fillStyle='rgba(255,215,0,0.95)';
          ctx.beginPath(); // losango
          ctx.moveTo(0,-4); ctx.lineTo(4,0); ctx.lineTo(0,4); ctx.lineTo(-4,0); ctx.closePath();
          ctx.fill();
          ctx.restore();
        }
      }
    });
  }

  // Magias (com CDR do Fate aplicado)
  function withFateCD(h, base){ return base * fateCDMul(h); }

  function castShield(caster){
    caster.shield=1.6;
    caster.cd.shield = withFateCD(caster, 6.0);
    SND.shield();
  }
  function castWave(caster){
    waves.push({x:caster.x,y:caster.y,r:10,max:140,w:10,t:0,dur:0.5,caster,hitSet:new Set(),isSuper:false});
    caster.cd.wave = withFateCD(caster, 3.2);
    SND.wave();
  }
  function castOrbFan(caster,target){
    if(!target) return;
    const dx=target.x-caster.x, dy=target.y-caster.y; const baseDir=Math.atan2(dy,dx);
    const spread=Math.PI/18, count=5, init=3.2;
    for(let i=0;i<count;i++){
      const off=(i-(count-1)/2)*spread; const a=baseDir+off; const u={x:Math.cos(a),y:Math.sin(a)};
      projectiles.push({x:caster.x+u.x*6,y:caster.y+u.y*6,vx:u.x*init,vy:u.y*init,r:3,ttl:3.0,caster,visualCaster:caster});
    }
    caster.cd.orb = withFateCD(caster, Math.max(0,+U.orbCd.value||2.5));
    SND.orb();
  }
  function castBoltTravel(caster,target){
    if(!target) return;
    const dx=target.x-caster.x, dy=target.y-caster.y; const d=Math.max(1,len2(dx,dy)); const u={x:dx/d,y:dy/d};
    const heroBolt = (+U.boltSpeed.value||12) * (caster.boltMul||1);
    const hitChance=caster.accBolt;
    let dir=Math.atan2(u.y,u.x); if(Math.random()>hitChance){ const maxAng=Math.PI/9; dir+=(Math.random()*2-1)*maxAng; }
    const vx=Math.cos(dir)*heroBolt, vy=Math.sin(dir)*heroBolt;
    bolts.push({x:caster.x,y:caster.y,vx,vy,w:3.5,ttl:2.6,caster,visualCaster:caster,path:[],ult:false,lethal:false});
    if(caster.cd) caster.cd.bolt = withFateCD(caster, Math.max(0,+U.boltCd.value||0));
    SND.zap();
  }

  // Wanda ‚Äî Passiva: Bolt Duplo a cada 10s (paralelos, mirando o alvo)
  function castWandaDoubleBolt(caster){
    if(!caster || !caster.alive) return;
    const target = nearestEnemyOf(caster); if(!target) return;
    const dx=target.x-caster.x, dy=target.y-caster.y;
    const d=Math.max(1, Math.hypot(dx,dy));
    const ux=dx/d, uy=dy/d;                   // dire√ß√£o ao alvo
    // perpendicular para separar os raios
    const px=-uy, py=ux;
    const offset=6.0;                          // separa√ß√£o lateral (paralelos)
    const speed=(+U.boltSpeed.value||12) * (caster.boltMul||1);
    // opcional: imprecis√£o padr√£o
    let dir=Math.atan2(uy,ux);
    if(Math.random()>caster.accBolt){ const maxAng=Math.PI/9; dir+=(Math.random()*2-1)*maxAng; }
    const vx=Math.cos(dir)*speed, vy=Math.sin(dir)*speed;

    // bolt 1 (lado +)
    bolts.push({
      x: caster.x + px*offset, y: caster.y + py*offset,
      vx, vy, w:3.5, ttl:2.6, caster, visualCaster:caster, path:[], ult:false, lethal:false
    });
    // bolt 2 (lado -)
    bolts.push({
      x: caster.x - px*offset, y: caster.y - py*offset,
      vx, vy, w:3.5, ttl:2.6, caster, visualCaster:caster, path:[], ult:false, lethal:false
    });
    SND.zap();
  }

  // ULTs
  function wandaUlt(h){
    const N=48, spread=2*Math.PI;
    const speed=(+U.boltSpeed.value||12)*1.15*(h.boltMul||1);
    for(let i=0;i<N;i++){
      const ang=(i/N)*spread; const vx=Math.cos(ang)*speed, vy=Math.sin(ang)*speed;
      bolts.push({ x:h.x, y:h.y, vx, vy, w:3.6, ttl:2.8, caster:h, visualCaster:h, path:[], ult:true, lethal:true });
    }
    // üõ°Ô∏è Escudo invulner√°vel vermelho (n√£o usa mais Ankh)
    h.wInvul = Math.max(h.wInvul||0, 2.0);

    effects.push({type:'boom',x:h.x,y:h.y,t:0,dur:0.8,color:hexToRgba(h.hex,1)}); h.ultCD = h.ultMax;
  }
  function fateUlt(h){
    h.ankh = 5.0; // dura√ß√£o ajustada
    for(let i=0;i<5;i++){
      setTimeout(()=>waves.push({x:h.x,y:h.y,r:12,max:220,w:10,t:0,dur:0.6,caster:h,isSuper:false,hitSet:new Set(),gold:true}), i*150);
    }
    SND.shield(); h.ultCD = h.ultMax;
  }
  function magnetoUltPlaceholder(h){
    // substitu√≠da pela Parte 4
    waves.push({x:h.x,y:h.y,r:16,max:260,w:14,t:0,dur:0.7,caster:h,isSuper:false,hitSet:new Set(),magnetic:true});
    effects.push({type:'boom',x:h.x,y:h.y,t:0,dur:0.9,color:'rgba(140,160,255,1)'}); SND.zap();
    h.ultCD = h.ultMax;
  }
function lokiUlt(h){
  if(!h.alive) return;
  spawnExplosion(h.x, h.y, hexToRgba('#00c853', 1));
  SND.zap();

  // ‚úÖ Shield padr√£o durante a ULT (n√£o usa Ankh)
  h.shield = Math.max(h.shield || 0, 2.5); // 2.5s de escudo

  spawnLokiClones(h, 6.0); // clones orbitando e atirando
  h.ultCD = h.ultMax;
}


  const ULT = {
    wanda:   wandaUlt,
    fate:    fateUlt,
    loki:    lokiUlt,
    magneto: magnetoUltPlaceholder
  };
  function heroUltimate(h){ if(h.ultCD>0 || !h.alive) return; (ULT[h.kit]||wandaUlt)(h); }

  // IA
  function aiTryCast(h,dt){
    h._think = (h._think||0) - dt; if(h._think>0) return;
    h._think = (h.thinkMin + Math.random()*(h.thinkMax-h.thinkMin));

    if(!U.battle.checked || !h.alive) return;
    const foe=nearestEnemyOf(h); if(!foe) return;
    const dx=foe.x-h.x, dy=foe.y-h.y, d=len2(dx,dy); const rng=+U.engage.value*2;
    const wantUlt = (h.id==='A'? U.autoUltA.checked : U.autoUltB.checked);

    if(wantUlt && h.ultCD<=0 && (d<rng*0.75 || h.hp<h.maxHp*0.45)){ heroUltimate(h); return; }
    if(U.mShield.checked && h.cd.shield<=0 && d<160){ castShield(h); return; }
    if(U.mWave.checked   && h.cd.wave  <=0 && d<120){ castWave(h);   return; }
    if(U.mBolt.checked   && h.cd.bolt  <=0){ castBoltTravel(h,foe); return; }
    if(U.mOrb.checked    && h.cd.orb   <=0){ castOrbFan(h,foe);     return; }
  }

  // Loki: blink ao bloquear com ESCUDO (n√£o com Ankh/wInvul)
  function tryLokiBlink(hero, originX, originY){
    if(hero.kit!=='loki') return;
    if(hero.ankh>0 || hero.wInvul>0) return; // n√£o durante invulns
    const now=performance.now();
    if(now < (hero._lokiBlinkNext||0)) return;
    hero._lokiBlinkNext = now + 550;

    const dx = hero.x - originX, dy = hero.y - originY;
    const d = Math.hypot(dx,dy) || 1;
    const dist = 200;
    const nx = dx/d, ny = dy/d;
    let tx = hero.x + nx*dist, ty = hero.y + ny*dist;

    const pad=8, WW=WW_get(), WH=WH_get();
    tx = clamp(tx, pad, WW-pad);
    ty = clamp(ty, pad, WH-pad);

    effects.push({type:'blink', x0:hero.x, y0:hero.y, x1:tx, y1:ty, t:0, dur:0.28, color:hexToRgba('#00c853',0.95)});
    SND.zap();

    hero.x = tx; hero.y = ty;
    hero.hasteUntil = now + 2000; // +20% vel por 2s
  }

  // F√≠sica / paredes
  function getSpeedMulNow(h){
    const now=performance.now();
    let mul = h.speedMul;
    if(now < (h.hasteUntil||0)) mul *= 1.20;         // haste de Loki
    return mul;
  }

  function stepHero(h,dt){
    if(!h.alive) return;

    const foe=nearestEnemyOf(h);

    // Passiva Wanda: contador do Bolt Duplo
    if(h.kit==='wanda'){
      h.wandaDoubleT = Math.max(0, (h.wandaDoubleT||0) - dt);
      if(h.wandaDoubleT<=0){
        castWandaDoubleBolt(h);
        h.wandaDoubleT = 10.0; // recarga fixa de 10s
      }
    }

    h.cd.bolt=Math.max(0,h.cd.bolt-dt);
    h.cd.orb=Math.max(0,h.cd.orb-dt);
    h.cd.wave=Math.max(0,h.cd.wave-dt);
    h.cd.shield=Math.max(0,h.cd.shield-dt);
    if(h.shield>0) h.shield=Math.max(0,h.shield-dt);
    if(h.ankh>0)   h.ankh  =Math.max(0,h.ankh  -dt);
    if(h.wInvul>0) h.wInvul=Math.max(0,h.wInvul-dt);
    if(h.ultCD>0)  h.ultCD =Math.max(0,h.ultCD -dt);
    if(h.grace>0)  h.grace =Math.max(0,h.grace -dt);

    const warp=(keys.shift?3:1);
    const base = +U.speed.value * getSpeedMulNow(h) * warp;

    // Gravidade de estrelas
    let ax=0, ay=0;
    const infl=+U.influence.value, fall=+U.falloff.value, Gg=+U.gravity.value;
    if(Gg>0 && stars.length){
      for(const s of stars){
        const dx=s.x-h.x, dy=s.y-h.y; const dist=Math.hypot(dx,dy);
        if(dist<infl){
          const soft=25; const G=Gg*s.massScale; const acc=G/(Math.pow(dist,fall)+soft);
          ax+=(dx/dist)*acc; ay+=(dy/dist)*acc;
          const curve=+U.curve.value; if(curve>0){ const tx=-dy/dist, ty=dx/dist; ax+=tx*base*curve*0.3*dt; ay+=ty*base*curve*0.3*dt; }
        }
      }
    }

    // Nitro
    if(foe && NITRO.force>0){
      const d=len2(foe.x-h.x,foe.y-h.y), rng=+U.engage.value*2;
      if(d<rng){
        let want=0; if(h.style==='attack') want=1; else if(h.style==='defense') want=-1; else want=(d>rng*0.6?1:(d<rng*0.35?-1:0));
        if(want!==0 && h.nitro.charge>0){
          const dir=Math.atan2(foe.y-h.y,foe.x-h.x)+(want<0?Math.PI:0);
          ax+=Math.cos(dir)*NITRO.force; ay+=Math.sin(dir)*NITRO.force;
          h.nitro.charge=Math.max(0,h.nitro.charge-dt);
        }
      }
    }

    // Movimento
    h.vx += ax*dt; h.vy += ay*dt;
    const drag=+U.drag.value; h.vx*=(1-drag*dt*60); h.vy*=(1-drag*dt*60);
    const vlen=Math.hypot(h.vx,h.vy);
    if(vlen<base){ const a=Math.atan2(h.vy,h.vx); h.vx+=Math.cos(a)*0.05*base*dt*60; h.vy+=Math.sin(a)*0.05*base*dt*60; }
    h.x += h.vx*dt*60; h.y += h.vy*dt*60;

    // Nitro recarga
    const cap=NITRO.cap, rec=NITRO.recharge; h.nitro.cap=cap; if(h.nitro.charge<cap) h.nitro.charge=Math.min(cap,h.nitro.charge+rec*dt);

    // Bordas = sem dano
    const pad=4;
    let nx=0, ny=0, hitWall=false;
    const WW = WW_get(), WH = WH_get();
    if(h.x<pad){ h.x=pad; h.vx=Math.abs(h.vx); hitWall=true; nx=1; }
    if(h.x>WW-pad){ h.x=WW-pad; h.vx=-Math.abs(h.vx); hitWall=true; nx=-1; }
    if(h.y<pad){ h.y=pad; h.vy=Math.abs(h.vy); hitWall=true; ny=1; }
    if(h.y>WH-pad){ h.y=WH-pad; h.vy=-Math.abs(h.vy); hitWall=true; ny=-1; }
    if(hitWall){ h.vx += nx*0.4; h.vy += ny*0.4; }

    // trilha
    h.trail.push({x:h.x,y:h.y,t:performance.now()}); if(h.trail.length>1200) h.trail.splice(0,h.trail.length-1200);
  }

  // Util colis√£o/barreira
  function distPointToSegment(px,py,x1,y1,x2,y2){
    const vx=x2-x1,vy=y2-y1,wx=px-x1,wy=py-y1; const c1=vx*wx+vy*wy; if(c1<=0) return Math.hypot(px-x1,py-y1);
    const c2=vx*vx+vy*vy; if(c2<=c1) return Math.hypot(px-x2,py-y2);
    const b=c1/c2; const bx=x1+vx*b,by=y1+vy*b; return Math.hypot(px-bx,py-by);
  }
  function closestPointOnSeg(x1,y1,x2,y2,cx,cy){
    const vx=x2-x1, vy=y2-y1; const l2=vx*vx+vy*vy||1; let t=((cx-x1)*vx+(cy-y1)*vy)/l2; t=Math.max(0,Math.min(1,t));
    return {x:x1+vx*t, y:y1+vy*t, t};
  }
  function reflect(vx,vy,nx,ny,rest=0.88){ const L=Math.hypot(nx,ny)||1e-6; nx/=L; ny/=L; const dot=vx*nx+vy*ny; return {vx:(vx-2*dot*nx)*rest, vy:(vy-2*dot*ny)*rest}; }
  function lineHitsBarrier(x1,y1,x2,y2,h){ const r=barrierRadius(h); const d=distPointToSegment(h.x,h.y,x1,y1,x2,y2); return d<=r+1; }

  function reboundProjectile(proj, prevX, prevY, hero){
    const cp=closestPointOnSeg(prevX,prevY,proj.x,proj.y,hero.x,hero.y);
    let nx=cp.x-hero.x, ny=cp.y-hero.y; const nd=Math.hypot(nx,ny)||1; nx/=nd; ny/=nd;
    const radProj = (proj.r ?? (proj.w ? proj.w*0.5 : 2));
    const safeR = barrierRadius(hero) + radProj + 0.5;
    proj.x = hero.x + nx*safeR; proj.y = hero.y + ny*safeR;

    const rv = reflect(proj.vx, proj.vy, nx, ny, 0.88); proj.vx = rv.vx; proj.vy = rv.vy;
    proj.visualCaster = hero; proj.ttl *= 0.92;

    // Loki: blink apenas quando for ESCUDO normal
    if(hero.kit==='loki' && hero.shield>0 && hero.ankh<=0 && hero.wInvul<=0){
      tryLokiBlink(hero, prevX, prevY);
    }

    effects.push({type:'hit',x:proj.x,y:proj.y,t:0,dur:0.25,color:'rgba(255,215,0,0.95)'});
  }

  function projectileColor(owner, fallback='rgba(200,220,255,0.9)'){
    if(!owner) return fallback;
    return owner.color || hexToRgba(owner.hex||'#ffffff',0.95);
  }

  // Orbes/bolts/waves/gamas
  function explodeOrb(p, hit=false, foe=null){
    const boomColor = p.visualCaster ? projectileColor(p.visualCaster) : (p.caster ? projectileColor(p.caster) : null);
    spawnExplosion(p.x, p.y, boomColor);
    if(hit && foe){
      const dx=foe.x-p.x, dy=foe.y-p.y; const d=Math.max(1,Math.hypot(dx,dy)); const k=0.35;
      damage(foe,18,{x:dx/d*k,y:dy/d*k}, p.caster?.id || null);
    }
  }

  // Gravidade dos ALVOS durante ULT do Magneto (atrai proj√©teis)
  function applyMagnetoTargetGravity(obj, dt){
    if(!magUlts.length) return;
    const Gm = +U.magUltG.value || 0;
    const R  = +U.magUltR.value || 0;
    if(Gm<=0 || R<=0) return;

    const fall = +U.falloff.value || 2.0;
    const soft = 18;
    for(const m of magUlts){
      const caster = m.caster;
      for(const h of heroes){
        if(!h.alive || h.id===caster.id) continue; // apenas advers√°rios
        const dx = h.x - obj.x, dy = h.y - obj.y;
        const dist = Math.hypot(dx,dy);
        if(dist>0 && dist<R){
          const acc = Gm / (Math.pow(dist,fall)+soft);
          obj.vx += (dx/dist)*acc*dt;
          obj.vy += (dy/dist)*acc*dt;
        }
      }
    }
  }

  function updateProjectiles(dt){
    const infl=+U.influence.value, fall=+U.falloff.value, Gg=+U.gravity.value, drag=+U.drag.value;
    const now=performance.now();

    // Orbes
    for(let i=projectiles.length-1;i>=0;i--){
      const p=projectiles[i]; const px=p.x, py=p.y;

      // Estrelas
      if(Gg>0 && stars.length){
        let ax=0, ay=0; const baseSwirl=clamp(+U.orbSwirl.value||0,0,1);
        for(const s of stars){
          const dx=s.x-p.x, dy=s.y-p.y; const dist=Math.hypot(dx,dy);
          if(dist>1e-3 && dist<infl){
            const rx=dx/dist, ry=dy/dist, tx=-ry, ty=rx;
            const soft=25; const G=Gg*s.massScale; const base=G/(Math.pow(dist,fall)+soft);
            const clos=clamp(1-(dist-s.r)/Math.max(1,(infl-s.r)),0,1);
            const swirlLocal=clamp((0.05+0.90*baseSwirl)*(0.75+0.25*clos),0,0.98);
            ax += (rx*(1-swirlLocal)+tx*swirlLocal)*base;
            ay += (ry*(1-swirlLocal)+ty*swirlLocal)*base;
          }
        }
        p.vx += ax*dt; p.vy += ay*dt;
      }

      applyMagnetoTargetGravity(p, dt);

      if(p.caster && p.caster.kit==='magneto' && now < (p.caster.magnetoRoamUntil||0)){
        const foe = nearestEnemyOf(p.caster);
        if(foe) steerTowards(p, foe.x, foe.y, 0.92);
      }

      if(drag>0){ p.vx*=(1-drag*dt*60*0.5); p.vy*=(1-drag*dt*60*0.5); }
      const vmax=8.0; const sp=Math.hypot(p.vx,p.vy); if(sp>vmax){ const f=vmax/sp; p.vx*=f; p.vy*=f; }
      p.x+=p.vx*dt*60; p.y+=p.vy*dt*60; p.ttl-=dt;

      let bounced=false;
      for(const h of enemiesOf(p.caster?.id||'')){
        if(!h.alive || !barrierActive(h)) continue;
        if(lineHitsBarrier(px,py,p.x,p.y,h)){ reboundProjectile(p,px,py,h); bounced=true; break; }
      }
      if(bounced){ continue; }

      if(p.ttl<=0){ explodeOrb(p); projectiles.splice(i,1); continue; }

      for(const foe of enemiesOf(p.caster?.id||'')){
        if(!foe.alive) continue;
        const dx=foe.x-p.x, dy=foe.y-p.y; if(Math.hypot(dx,dy) < foe.r + p.r){ explodeOrb(p,true,foe); projectiles.splice(i,1); break; }
      }
    }

    // Bolts
    for(let i=bolts.length-1;i>=0;i--){
      const b=bolts[i]; const px=b.x,py=b.y;

      if(Gg>0 && stars.length){
        let ax=0, ay=0;
        for(const s of stars){
          const dx=s.x-b.x, dy=s.y-b.y; const dist=Math.hypot(dx,dy);
          if(dist>1e-3 && dist<infl){
            const soft=22; const G=Gg*s.massScale; const a=G/(Math.pow(dist,fall)+soft);
            ax+=(dx/dist)*a; ay+=(dy/dist)*a;
          }
        }
        b.vx+=ax*dt; b.vy+=ay*dt;
      }

      applyMagnetoTargetGravity(b, dt);

      if(b.caster && b.caster.kit==='magneto' && now < (b.caster.magnetoRoamUntil||0)){
        const foe = nearestEnemyOf(b.caster);
        if(foe) steerTowards(b, foe.x, foe.y, 0.93);
      }

      if(drag>0){ b.vx*=(1-drag*dt*60*0.25); b.vy*=(1-drag*dt*60*0.25); }
      const baseSpeed=(+U.boltSpeed.value||12);
      const vmax=b.ult?baseSpeed*(1.8):(Math.max(baseSpeed, baseSpeed*1.5));
      const sp=Math.hypot(b.vx,b.vy); if(sp>vmax){ const f=vmax/sp; b.vx*=f; b.vy*=f; }

      b.x+=b.vx*dt*60; b.y+=b.vy*dt*60; b.ttl-=dt;
      b.path.push({x:b.x,y:b.y}); if(b.path.length>90) b.path.shift();

      let bounced=false;
      for(const h of enemiesOf(b.caster?.id||'')){
        if(!h.alive || !barrierActive(h)) continue;
        if(lineHitsBarrier(px,py,b.x,b.y,h)){ reboundProjectile(b,px,py,h); bounced=true; break; }
      }
      if(bounced){ continue; }

      let hit=false;
      for(const foe of enemiesOf(b.caster?.id||'')){
        if(!foe.alive) continue;
        const dx=foe.x-b.x, dy=foe.y-b.y; const dist=Math.hypot(dx,dy);
        if(dist < foe.r + b.w*0.8){
          const ratio = (+U.boltDmg.value || 0);
          let dmg;
          if (b.ult && b.lethal) dmg = foe.maxHp * 10;
          else if (ratio>=0.999) dmg = foe.maxHp * 10;
          else dmg = foe.maxHp * Math.max(0, Math.min(1, ratio));
          const nx=dist>0?(dx/dist):0, ny=dist>0?(dy/dist):0;
          damage(foe, dmg, {x:nx*0.10, y:ny*0.10}, b.caster?.id || null);
          hit=true; break;
        }
      }
      if(hit){ bolts.splice(i,1); continue; }

      const WW=WW_get(), WH=WH_get();
      if(b.ttl<=0 || b.x<-200 || b.y<-200 || b.x>WW+200 || b.y>WH+200){ bolts.splice(i,1); continue; }
    }

    // Ondas
    for(let i=waves.length-1;i>=0;i--){
      const w=waves[i]; w.t+=dt; w.r+=(w.max/w.dur)*dt; if(w.t>=w.dur){ waves.splice(i,1); continue; }
      for(const h of heroes){
        if(!h.alive) continue;
        const d=Math.hypot(h.x-w.x,h.y-w.y);
        if(d>w.r-w.w && d<w.r+w.w && !(w.hitSet.has(h))){
          const dir={x:(h.x-w.x)/d,y:(h.y-w.y)/d};
          if(!w.caster){
            if(!isInvulnerable(h)) damage(h,60,{x:dir.x*1.5,y:dir.y*1.5}, null);
          }else if(h.id!==w.caster.id){
            if(!isInvulnerable(h)) damage(h,12,{x:dir.x*0.9,y:dir.y*0.9}, w.caster?.id || null);
          }
          w.hitSet.add(h);
        }
      }
    }

    for(let i=effects.length-1;i>=0;i--){ const e=effects[i]; e.t+=dt; if(e.t>=e.dur) effects.splice(i,1); }

    const snRate=+U.supernovaRate.value;
    if(snRate>0){ const p=snRate*0.25*dt; if(Math.random()<p) triggerSupernova(); }
  }

  function triggerSupernova(){
    if(!stars.length) return;
    const s=stars[Math.floor(Math.random()*stars.length)];
    waves.push({ x:s.x, y:s.y, r:8, max:320+Math.random()*260, w:14, t:0, dur:0.9, caster:null, isSuper:true, hitSet:new Set() });
    effects.push({type:'boom', x:s.x, y:s.y, t:0, dur:0.9, color:'rgba(255,220,180,1)'}); SND.supernova();
    if(s.type==='supergiant' && Math.random()<0.5){ s.type='neutron'; s.r=Math.max(8, s.r*0.4); s.massScale=STAR_TYPES.neutron.massScale; }
  }

  // Raios-gama
  (function setupGamma(){
    const GAMMA_TYPES=new Set(['neutron','pulsar','magnetar','black_hole']);
    function canEmitGamma(star){ return U.mGamma?.checked && GAMMA_TYPES.has(star.type); }
    function spawnGammaFromStar(star){
      const speed=Math.max(10,+U.gammaSpeed?.value||80);
      const width=Math.max(2,(+U.gammaW?.value||6)*(0.6+Math.random()*0.9));
      let ang;
      if(star.type==='pulsar'){ star.gammaPol=!star.gammaPol; ang=star.spin+(star.gammaPol?0:Math.PI); }
      else if(star.type==='black_hole'){ ang=star.spin*0.7+(Math.random()*0.6-0.3); }
      else { ang=star.spin+(Math.random()*0.4-0.2); }
      const ux=Math.cos(ang), uy=Math.sin(ang);
      gBeams.push({ x:star.x,y:star.y,lx:star.x,ly:star.y,vx:ux*speed,vy:uy*speed,w:width,ttl:1.2 });
      SND.gamma();
    }

    const _updateProjectiles = updateProjectiles;
    updateProjectiles = function(dt){
      const rate=Math.max(0,+U.gammaRate?.value||0);
      if(rate>0 && U.mGamma?.checked){
        const p=rate*dt;
        for(const s of stars){ if(canEmitGamma(s) && Math.random()<p) spawnGammaFromStar(s); }
      }
      _updateProjectiles(dt);

      for(let i=gBeams.length-1;i>=0;i--){
        const b=gBeams[i]; const px=b.x,py=b.y;
        b.x+=b.vx*dt*60; b.y+=b.vy*dt*60; b.ttl-=dt;

        let blocked=false;
        for(const h of heroes){
          if(!h.alive || !barrierActive(h)) continue;
          if(lineHitsBarrier(px,py,b.x,b.y,h)){ blocked=true; effects.push({type:'hit',x:b.x,y:b.y,t:0,dur:0.25,color:'rgba(255,215,0,0.95)'}); break; }
        }
        if(blocked){ gBeams.splice(i,1); continue; }

        for(const h of heroes){
          if(!h.alive) continue;
          const d=distPointToSegment(h.x,h.y,px,py,b.x,b.y);
          if(d<=h.r + b.w*0.5){
            damage(h, 85, {x:0,y:0}, null);
          }
        }
        b.lx=px; b.ly=py;

        const WW=WW_get(), WH=WH_get();
        if(b.ttl<=0 || b.x<-300 || b.y<-300 || b.x>WW+300 || b.y>WH+300) gBeams.splice(i,1);
      }
    };
  })();

  // Desenho proj√©teis/efeitos + campos/ilus√µes
  function drawProjectiles(){
    withCamera(()=>{
      for(const p of projectiles){
        ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2-1e-4);
        const owner = p.visualCaster ?? p.caster;
        const col = projectileColor(owner, 'rgba(200,220,255,0.9)');
        ctx.fillStyle=col; ctx.shadowBlur=10; ctx.shadowColor=col; ctx.fill(); ctx.shadowBlur=0;
      }
      for(const w of waves){
        const owner = w.caster || null;
        const col = owner ? projectileColor(owner, 'rgba(180,220,255,0.7)') : (w.isSuper?'rgba(255,210,150,0.95)':'rgba(180,220,255,0.7)');
        ctx.lineWidth=w.w; ctx.strokeStyle=col; ctx.beginPath(); ctx.arc(w.x,w.y,w.r,0,Math.PI*2-1e-4); ctx.stroke();
      }
      for(const b of bolts){
        const path=b.path; if(path&&path.length>1){
          const owner = b.visualCaster ?? b.caster;
          const col = projectileColor(owner, 'rgba(255,255,255,0.9)');
          ctx.globalAlpha=0.9; ctx.strokeStyle=col; ctx.lineWidth=b.ult?3.3:2.6; ctx.lineJoin='round';
          ctx.beginPath(); ctx.moveTo(path[0].x,path[0].y); for(let i=1;i<path.length;i++) ctx.lineTo(path[i].x,path[i].y); ctx.stroke(); ctx.globalAlpha=1;
        }
        ctx.beginPath(); ctx.arc(b.x,b.y,b.ult?4.2:3.7,0,Math.PI*2-1e-4);
        const owner2 = b.visualCaster ?? b.caster;
        const col2 = projectileColor(owner2, 'rgba(255,255,255,0.95)');
        ctx.fillStyle=col2; ctx.shadowBlur=18; ctx.shadowColor=ctx.fillStyle; ctx.fill(); ctx.shadowBlur=0;
      }
      for(const e of effects){
        if(e.type==='boom'){
          const prog=e.t/e.dur; const r=10+prog*40; const a=1-Math.pow(prog,1.4); const base=e.color||'rgba(255,220,180,1)';
          ctx.fillStyle=base.replace('1)', `${0.25*a})`).replace('0.95)','0.25)'); ctx.beginPath(); ctx.arc(e.x,e.y,r*2,0,Math.PI*2-1e-4); ctx.fill();
          ctx.strokeStyle=base.replace('1)', `${0.9*a})`).replace('0.95)','0.9)'); ctx.lineWidth=2; ctx.beginPath(); ctx.arc(e.x,e.y,r,0,Math.PI*2-1e-4); ctx.stroke();
        } else if(e.type==='hit'){
          const prog=e.t/e.dur; const a=1-prog; const base=e.color||'rgba(255,255,255,0.9)';
          ctx.fillStyle=base; ctx.beginPath(); ctx.arc(e.x,e.y,2+8*prog,0,Math.PI*2-1e-4); ctx.globalAlpha=0.7*a; ctx.fill(); ctx.globalAlpha=1;
        } else if(e.type==='blink'){
          const prog=e.t/e.dur;
          const a=1-prog;
          strokeHalo(e.x0,e.y0,10+30*prog,2,hexToRgba('#00c853',0.85*a));
          strokeHalo(e.x1,e.y1,10+30*prog,2,hexToRgba('#00c853',0.85*a));
          ctx.save(); ctx.globalAlpha = 0.85*a; ctx.strokeStyle=hexToRgba('#00c853',0.95*a); ctx.lineWidth=2.2;
          ctx.beginPath();
          ctx.moveTo(e.x0,e.y0);
          const mx=(e.x0+e.x1)/2, my=(e.y0+e.y1)/2;
          const nx=-(e.y1-e.y0), ny=(e.x1-e.x0);
          const k=0.15;
          ctx.quadraticCurveTo(mx+nx*k, my+ny*k, e.x1, e.y1);
          ctx.stroke();
          ctx.restore();
        }
      }
    });
  }

  // UI
  const keys={shift:false, space:false};
  addEventListener('keydown',e=>{
    const k=(e.key||'').toLowerCase();
    if(k==='shift') keys.shift=true;
    if(k===' ') keys.space=true;
  });
  addEventListener('keyup',e=>{
    const k=(e.key||'').toLowerCase();
    if(k==='shift') keys.shift=false;
    if(k===' ') keys.space=false;
  });

  U.randomize.onclick = seedVelocities;
  U.reset.onclick = ()=>{
    for(const h of heroes){ Object.assign(h, makeHero(h.id)); }
    scores.A=0; scores.B=0; updateScores();
    effects.length=projectiles.length=bolts.length=waves.length=gBeams.length=0;
    magUlts.length=0;
    illusions.length=0;
  };
  U.resetBattle.onclick = U.reset.onclick;

  let paused=false;
  U.pause.onclick=()=>{ paused=!paused; U.pause.textContent=paused?'Retomar':'Pausar'; };
  U.zeroV.onclick=()=>{ for(const h of heroes){ h.vx=0; h.vy=0; } };

  U.addHeroA.onclick=()=>addHero('A');
  U.addHeroB.onclick=()=>addHero('B');

  addEventListener('cosmo:ultA', ()=>{ const h=heroesOf('A')[0]; if(h) heroUltimate(h); });
  addEventListener('cosmo:ultB', ()=>{ const h=heroesOf('B')[0]; if(h) heroUltimate(h); });

  // Loop
  let last=performance.now();
  let fpsAcc=0,fpsCount=0,fpsLast=performance.now();
  let dtGlobal=0;

  function drawMagnetoFields(){
    const now=performance.now(); purgeMagUlts(now);
    withCamera(()=>{
      for(const m of magUlts){
        const h = m.caster; if(!h.alive) continue;
        const alpha = 0.20 + 0.15*Math.sin(now/200);
        const r = 78 + 8*Math.sin(now/140);
        ctx.lineWidth = 2.4;
        ctx.strokeStyle = hexToRgba(h.hex, 0.75);
        ctx.beginPath(); ctx.arc(h.x,h.y,r,0,Math.PI*2-1e-4); ctx.stroke();
        ctx.globalAlpha = 0.12 + alpha*0.5;
        fillCircle(h.x,h.y,r*0.95,hexToRgba(h.hex,0.12));
        ctx.globalAlpha = 1;
      }
    });
  }

  function frame(t){
    requestAnimationFrame(frame);
    const dt=Math.min(0.06,(t-last)/1000); last=t;
    dtGlobal = dt;
    if(paused) return;

    drawBackground();
    for(const h of heroes) tryRespawn(h);
    for(const h of heroes) stepHero(h,dt);
    for(const h of heroes) aiTryCast(h,dt);

    updateIllusions(dt);
    updateProjectiles(dt);

    drawStarfield();
    for(const s of stars) drawStar(s);
    drawProjectiles();
    drawMagnetoFields();
    drawIllusions();
    for(const h of heroes) drawHero(h);

    const inst=1/Math.max(0.001,dt); fpsAcc+=inst; fpsCount++; if(t-fpsLast>400){ U.fps.textContent=`${Math.round(fpsAcc/fpsCount)} fps`; fpsAcc=0; fpsCount=0; fpsLast=t; }
  }
  requestAnimationFrame(frame);

  // Exposi√ß√£o para Parte 4
  window.__COSMO_GAME__ = {
    heroes, stars, projectiles, bolts, waves, effects, gBeams,
    WW: () => WW_get(),
    WH: () => WH_get(),
    damage, kill, spawnExplosion, spawnHit,
    barrierActive, barrierRadius,
    hexToRgba, clamp, unit, len2, SND,
    setUltimate: (heroKey, fn)=>{ ULT[heroKey]=fn; },
    getUltimate: (heroKey)=> ULT[heroKey],
    getBoltSpeedFor: (h)=> ((+U.boltSpeed.value||12) * (h.boltMul||1)),
    addProjectile: (obj)=>{ projectiles.push(obj); },
    addBolt: (obj)=>{ bolts.push(obj); },
    addWave: (obj)=>{ waves.push(obj); },

    // campos de for√ßa / ult
    addMagnetoField
  };

})(); // fim Parte 3/4
</script>
<script>
/* =========================================================
   COSMOS ‚Äî ULT do Magneto (Parte 4/4)
   ‚Ä¢ Campo magn√©tico por ~2.2s (addMagnetoField)
   ‚Ä¢ "Puxa" proj√©teis/bolts inimigos ao alvo mais pr√≥ximo
   ‚Ä¢ Recolore/reatribui proj√©teis capturados ao Magneto
   ‚Ä¢ Termina se o caster morrer
   ========================================================= */
(() => {
  const G = window.__COSMO_GAME__;
  if (!G) { console.error('[Magneto ULT] __COSMO_GAME__ indispon√≠vel.'); return; }

  const {
    heroes, projectiles, bolts,
    spawnExplosion, hexToRgba, SND,
    addMagnetoField
  } = G;

  // utilidades locais
  function enemiesAliveOf(team){
    const out=[]; for(const h of heroes){ if(h.id!==team && h.alive) out.push(h); } return out;
  }
  function nearest(list,x,y){
    let best=null,bd=Infinity;
    for(const it of list){
      const dx=it.x-x, dy=it.y-y; const d=dx*dx+dy*dy;
      if(d<bd){ bd=d; best=it; }
    }
    return best;
  }
  // blend ‚àà [0..1] ‚Äî 1 = seguir imediatamente a dire√ß√£o alvo mantendo o mesmo m√≥dulo da velocidade
  function steerTowards(obj, tx, ty, blend){
    const dx=tx-obj.x, dy=ty-obj.y;
    const d=Math.max(1, Math.hypot(dx,dy));
    const sp=Math.hypot(obj.vx||0,obj.vy||0) || 1;
    const tvx=dx/d*sp, tvy=dy/d*sp;
    obj.vx=(obj.vx||0)*(1-blend)+tvx*blend;
    obj.vy=(obj.vy||0)*(1-blend)+tvy*blend;
  }

  function magnetoUlt(caster){
    if (!caster || !caster.alive) return;

    // FX inicial + campo de for√ßa/gravidade de alvo (Parte 3 aplicar√° gravidade em updateProjectiles)
    spawnExplosion(caster.x, caster.y, hexToRgba(caster.hex, 1));
    SND.zap();

    const durMs = 2200;
    addMagnetoField(caster, durMs);

    // alvo din√¢mico (sempre o inimigo vivo mais pr√≥ximo)
    let target = nearest(enemiesAliveOf(caster.id), caster.x, caster.y);

    const start = performance.now();
    const BLEND_ORB  = 0.94; // homing forte para orbes
    const BLEND_BOLT = 0.96; // homing ainda mais forte para bolts

    function controlLoop(){
      // encerra se o caster morrer ou o tempo acabar
      const now = performance.now();
      if (!caster.alive || (now - start) >= durMs) return;

      // atualiza alvo
      if (!target || !target.alive){
        target = nearest(enemiesAliveOf(caster.id), caster.x, caster.y);
      }

      if (target){
        // ORBES inimigos: magnetiza e "toma" posse visual
        for (const p of projectiles){
          if (!p) continue;
          const ownerTeam = (p.caster && p.caster.id) ? p.caster.id : null;
          if (ownerTeam && ownerTeam !== caster.id){
            steerTowards(p, target.x, target.y, BLEND_ORB);
            if (p.caster !== caster){
              p._origCaster = p.caster || null;
              p.caster = caster;
              p.visualCaster = caster; // recolor/placar para Magneto
            }
          }
        }

        // BOLTS inimigos: idem, com blend maior
        for (const b of bolts){
          if (!b) continue;
          const ownerTeam = (b.caster && b.caster.id) ? b.caster.id : null;
          if (ownerTeam && ownerTeam !== caster.id){
            steerTowards(b, target.x, target.y, BLEND_BOLT);
            if (b.caster !== caster){
              b._origCaster = b.caster || null;
              b.caster = caster;
              b.visualCaster = caster;
            }
          }
        }
      }

      requestAnimationFrame(controlLoop);
    }
    requestAnimationFrame(controlLoop);

    // recarga da ULT
    caster.ultCD = caster.ultMax;
  }

  // instala/substitui a ULT do Magneto
  G.setUltimate('magneto', magnetoUlt);
})();
</script>
